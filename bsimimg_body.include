// *****************************************************************************************
// *  BSIM-IMG 103.1.0beta0_2 released on 12/29/2023                                       *
// *  BSIM Independent Multi-Gate Model (Verilog-A)                                        *
// *****************************************************************************************

// *****************************************************************************************
// *  Copyright Â© 2023 University of California                                            *
// *                                                                                       *
// *  Project director: Prof. Chenming Hu                                                  *
// *                                                                                       *
// *  Current developers: Dinesh Rajasekharan     (Postdoc, UC Berkeley)                   *
// *                      Girish Pahwa            (Assistant Researcher, UC Berkeley)      *
// *                      Ahtisham Pampori        (Postdoc, UC Berkeley)                   *
// *                      Chetan K. Dabhi         (Postdoc, UC Berkeley)                   *
// *                      Chien-Ting Tung         (Ph.D., UC Berkeley)                     *
// *                      Jen Hao Chen            (Ph.D., UC Berkeley)                     *
// *****************************************************************************************


// Clamped exponential function
analog function real lexp;
    input x;
    real x;

    begin
        if (x > `EXPL_THRESHOLD) begin
            lexp = `MAX_EXPL * (1.0 + x - `EXPL_THRESHOLD);
        end else if (x < -`EXPL_THRESHOLD) begin
            lexp = `MIN_EXPL;
        end else begin
            lexp = exp(x);
        end
    end
endfunction

// Clamped log function
analog function real lln;
    input x;
    real x;

    begin
        lln = ln(max(x, `N_MINLOG));
    end
endfunction

// Hyperbolic smoothing function
analog function real hypsmooth;
    input x, c;
    real x, c;

    begin
        hypsmooth = 0.5 * (x + sqrt(x * x + 4.0 * c * c));
    end
endfunction

// Hyperbolic smooth max function
analog function real hypmax;
    input x, xmin, c;
    real x, xmin, c;

    begin
        hypmax = xmin + 0.5 * (x - xmin - c + sqrt((x - xmin - c) * (x - xmin - c) - 4.0 * xmin * c));
    end
endfunction

// Smooth function to fix minimum value of a variable
analog function real smoothminx;
    input x, x0, deltax;
    real x, x0, deltax;
    begin
        smoothminx = 0.5 * (x + x0 + sqrt((x - x0) * (x - x0) + 0.25 * deltax * deltax));
    end
endfunction

// Smoothing function for (min of x, x0 with deltax)
analog function real minx;
    input x, x0, deltax;
    real x, x0, deltax;

    begin
        minx = 0.5 * (x + x0 - sqrt((x - x0) * (x - x0) + 0.25 * deltax * deltax));
    end
endfunction

// ***************************
// **  Instance Parameters  **
// ***************************
// Note: Some instance parameters are also model parameters. Please refer to the technical note for details.

`IPRco( L              ,3.0e-8         ,"m"           ,1.0e-9      ,inf         ,"Designed Gate Length" )
`IPRco( W              ,1.0e-6         ,"m"           ,1.0e-9      ,inf         ,"Designed Gate Width" )
`IPIco( NF             ,1              ,""            ,1           ,inf         ,"Number of fingers" )
`IPRcz( AS             ,0.0            ,"m^2"                                   ,"Source area" )
`IPRcz( AD             ,0.0            ,"m^2"                                   ,"Drain area" )
`IPRcz( PS             ,0.0            ,"m"                                     ,"Source perimeter" )
`IPRcz( PD             ,0.0            ,"m"                                     ,"Drain perimeter" )
`IPRcz( NRS            ,0.0            ,""                                      ,"Number of source diffusion squares" )
`IPRcz( NRD            ,0.0            ,""                                      ,"Number of drain diffusion squares" )

// Variability Handles
`IPRnb( DTEMP          ,0.0            ,"Celsius"                               ,"Variability in Device Temperature" )
`IPRnb( DELVTRAND      ,0.0            ,"V"                                     ,"Variability in Vth" )
`IPRoz( U0MULT         ,1.0            ,""                                      ,"Variability in carrier mobility" )
`IPRcz( MULT_I         ,1.0            ,""                                      ,"Variability in current")
`IPRcz( MULT_Q         ,1.0            ,""                                      ,"Variability in charge")
`IPRcz( MULT_FN        ,MULT_I         ,""                                      ,"Variability in flicker noise")

// ************************
// **  Model Parameters  **
// ************************
`MPIty( TYPE           ,`ntype         ,""                                      ,"NMOS=1, PMOS=-1" )
`MPIty( WELLTYPE       ,-TYPE          ,""                                      ,"Well (substrate) type" )
`MPIcc( RDSMOD         ,0              ,""            ,0           ,2           ,"0: Bias-dependent S/D resistances internal and bias-independent S/D resistances external, 1: External s/d resistance model, 2: Both bias dependent and independent part of source/drain resistance internal" )
`MPIcc( GIDLMOD        ,0              ,""            ,0           ,1           ,"0: Turn off GIDL/GISL current, 1: Turn on GIDL/GISL current" )
`MPIcc( IGCMOD         ,0              ,""            ,0           ,1           ,"0: Turn off Igc, Igs and Igd, 1: Turn on Igc, Igs and Igd" )
`MPIcc( IGBMOD         ,0              ,""            ,0           ,1           ,"0: Turn off Igb" )
`MPIcc( SHMOD          ,0              ,""            ,0           ,1           ,"0: No self-heating" )
`MPIcc( RGATEMOD       ,0              ,""            ,0           ,1           ,"Gate resistance model selector" )
`MPIcc( NQSMOD         ,0              ,""            ,0           ,1           ,"0: Turn off NQS model; 1: NQS gate resistance (with gi node)" )
`MPIcc( NFMOD          ,0              ,""            ,0           ,1           ,"0: W taken as total width like BSIM4, 1: W taken as single finger width  " )
`MPIcc( FNMOD          ,0              ,""            ,0           ,1           ,"Flicker noise model 0: Old, 1: Improved" )
`MPRnb( XL             ,0.0            ,"m"                                     ,"L offset for channel length due to mask/etch effect" )
`MPRnb( XW             ,0.0            ,"m"                                     ,"W offset for channel width due to mask/etch effect" )
`MPRnb( LINT           ,0.0            ,"m"                                     ,"Delta L for IV" )
`MPRnb( LL             ,0.0            ,"m^(1+LLN)"                             ,"Length reduction parameter (dopant diffusion effect)" )
`MPRnb( LW             ,0.0            ,"m^(1+LWN)"                             ,"Length scaling parameter" )
`MPRnb( LWL            ,0.0            ,"m^(LWN+LLN+1)"                         ,"Length scaling parameter" )
`MPRnb( LLN            ,1.0            ,""                                      ,"Length reduction parameter (dopant diffusion effect)" )
`MPRnb( LWN            ,1.0            ,""                                      ,"Length scaling parameter" )
`MPRnb( WINT           ,0.0            ,"m"                                     ,"Delta W for IV" )
`MPRnb( WL             ,0.0            ,"m^(1+WLN)"                             ,"Width reduction parameter (dopant diffusion effect)" )
`MPRnb( WW             ,0.0            ,"m^(1+WWN)"                             ,"Width scaling parameter" )
`MPRnb( WWL            ,0.0            ,"m^(WLN+WWN+1)"                         ,"Width scaling parameter" )
`MPRnb( WLN            ,1.0            ,""                                      ,"Width reduction parameter (dopant diffusion effect)" )
`MPRnb( WWN            ,1.0            ,""                                      ,"Width scaling parameter" )
`MPRnb( DLC            ,0.0            ,"m"                                     ,"Delta L for CV" )
`MPRnb( LLC            ,0.0            ,"m"                                     ,"Length scaling parameter" )
`MPRnb( LWC            ,0.0            ,"m"                                     ,"Length scaling parameter" )
`MPRnb( LWLC           ,0.0            ,"m"                                     ,"Length scaling parameter" )
`MPRnb( DWC            ,0.0            ,"m"                                     ,"Delta W for CV" )
`MPRnb( WLC            ,0.0            ,"m"                                     ,"Width scaling parameter" )
`MPRnb( WWC            ,0.0            ,"m"                                     ,"Width scaling parameter" )
`MPRnb( WWLC           ,0.0            ,"m"                                     ,"Width scaling parameter" )

`MPRco( EOT1           ,1.0e-9         ,"m"           ,0.1e-9      ,inf         ,"Equivalent front gate dielectric thickness relative to SiO2" )
`MPRco( EOT2           ,1.0e-8         ,"m"           ,0.1e-9      ,inf         ,"Equivalent back  gate dielectric thickness relative to SiO2" )
`MPRco( EOT1P          ,EOT1           ,"m"           ,0.1e-9      ,inf         ,"Equivalent physical front gate dielectric thickness relative to SiO2" )
`MPRnb( DTOX1          ,0.0            ,"m"                                     ,"Difference between effective dielectric thickness and physical thickness" )
`MPRco( TSI            ,8.0e-9         ,"m"           ,1.0e-9      ,inf         ,"Body thickness" )
`MPRcc( NBODY          ,1.0e22         ,"m^-3"        ,1.0e18      ,5.0e24      ,"Channel (body) doping" )
`MPRcc( NSD            ,2.0e26         ,"m^-3"        ,2.0e25      ,1.0e27      ,"Source/drain active doping concentration" )
`MPRcz( NBG            ,5.0e23         ,"m^-3"                                  ,"Well/substrate (or also called back-gate) doping, zero for metal" )
`MPRcz( EASUB          ,4.05           ,"eV"                                    ,"Electron affinity of well/substrate" )
`MPRoz( NI0SUB         ,1.1e16         ,"m^-3"                                  ,"Intrinsic carrier constant at 300.15K" )
`MPRoz( BG0SUB         ,1.12           ,"eV"                                    ,"Band gap of well/substrate at 300.15K" )
`MPRoz( PHIG1          ,4.61           ,"eV"                                    ,"Front Gate Workfunction" )
`MPRoz( PHIG2          ,((WELLTYPE == `ptype) ? (EASUB + BG0SUB) : EASUB),"eV"  ,"Back gate workfunction, will be modified according to NBG later in the code" )
`MPRoz( EPSRSUB        ,11.9           ,""                                      ,"Relative dielectric constant of the channel material" )
`MPRoz( EPSROX1        ,3.9            ,""                                      ,"Relative dielectric constant of the front gate dielectric" )

 // Short Channel Effects
`MPRnb( ASCL           ,0.0            ,""                                      ,"Parameter for back-gate dependent scale length" )
`MPRnb( BSCL           ,0.0            ,"V^-1"                                  ,"Parameter for back-gate dependent scale length" )
`MPRnb( CIT            ,0.0            ,"F/(m^2)"                               ,"Parameter for interface trap" )
`MPRnb( CDSC           ,0.14           ,"F/(m^2)"                               ,"Coupling capacitance between S/D and channel" )
`MPRnb( CDSCD          ,0.14           ,"F/(m^2*V)"                             ,"Drain-bias sensitivity of CDSC" )
`MPRnb( CBGCBG0        ,0.0            ,"F/(m^2*V)"                             ,"Backgate-bias sensitivity of SS for long channel" )
`MPRnb( CBGCBG0P       ,0.0            ,"F/(m^2*V^2)"                           ,"Backgate-bias sensitivity of SS for long channel" )
`MPRnb( CBGCBG         ,0.0            ,"F/(m^2*V)"                             ,"Backgate-bias sensitivity of CDSC" )
`MPRnb( CBGCBGP        ,0.0            ,"F/(m^2*V^2)"                           ,"Nonlinear backgate-bias sensitivity of SS" )
`MPRnb( CBGCBGD        ,0.0            ,"F/(m^2*V^2)"                           ,"Backgate-bias sensitivity of CDSCD" )
`MPRnb( DVT0           ,19.2           ,""                                      ,"SCE coefficient" )
`MPRnb( DVT1           ,0.45           ,""                                      ,"SCE exponent coefficient" )
`MPRnb( PHIN           ,0.045          ,"V"                                     ,"Nonuniform vertical doping effect on surface potential" )
`MPRnb( ETA0           ,2.0            ,""                                      ,"DIBL coefficient 1" )
`MPRnb( ETA1           ,0.00           ,""                                      ,"DIBL coefficient for low gate overdrive" )
`MPRnb( DSUB           ,0.375          ,""                                      ,"DIBL coefficient 2 (exponent coefficient)" )
`MPRnb( DVTP0          ,0              ,""                                      ,"Coefficient for Drain-Induced Vth Shift (DITS)" )
`MPRnb( DVTP1          ,0              ,""                                      ,"DITS exponent coefficient" )
`MPRnb( ADVTP0         ,0.0            ,""                                      ,"Pre-exponential Coefficient for DITS" )
`MPRex( BDVTP0         ,100.0e-9       ,"m"           ,0.0                      ,"Exponential coefficient for DITS" )
`MPRnb( ADVTP1         ,0.0            ,""                                      ,"Pre-exponential coefficient for DVTP1" )
`MPRex( BDVTP1         ,100.0e-9       ,"m"           ,0.0                      ,"Exponential coefficient for DVTP1" )
`MPRnb( DVTP2          ,0.0            ,""                                      ,"DITS Model Parameter" )
`MPRnb( ETAB           ,0.00           ,"V^-1"                                  ,"DIBL coefficient - Back Gate dependence" )
`MPRnb( K1RSCE         ,-0.32          ,"V^(1/2)"                               ,"Vt Roll-off at moderate Lg" )
`MPRnb( LPE0           ,8.2e-9         ,"m"                                     ,"Equivalent length of pocket region at zero bias" )
`MPRnb( DSC0           ,0.0            ,"m"                                     ,"Parameter for short channel effect at moderate L and high drain bias" )
`MPRnb( DSC1           ,1.0e-9         ,"m"                                     ,"Parameter for short channel effect at moderate L and high drain bias" )

// Lateral non-uniform doping effect (IV-CV Vth shift)
`MPRnb( K0             ,0.0            ,"V"                                     ,"Lateral NUD voltage parameter" )
`MPRnb( K01            ,0.0            ,"V/K"                                   ,"Temperature dependence of lateral NUD voltage parameter" )
`MPRnb( K0SI           ,1.0            ,""                                      ,"Correction factor for strong inversion, used in Mnud, after binning should be from (0:inf)" )
`MPRnb( K0SI1          ,0.0            ,"K^-1"                                  ,"Temperature dependence of K0SI" )
`MPRnb( K0SISAT        ,0.0            ,""                                      ,"Correction factor for strong inversion, used in Mnud" )
`MPRnb( K0SISAT1       ,0.0            ,""                                      ,"Temperature dependence of K0SISAT" )

// Quantum Mechanical Effects

`MPRnb( QMTCENCV       ,0.0            ,""                                      ,"Prefactor + switch for QM Width and Toxeff correction for CV" )
`MPRnb( ETAQM          ,0.54           ,""                                      ,"Bulk charge coefficient for Tcen" )
`MPRoz( QM0            ,1.0e-3         ,"V"                                     ,"Knee-Point for Tcen in inversion (Charge normalized to Cox)" )
`MPRnb( PQM            ,0.66           ,""                                      ,"Slope of normalized Tcen in inversion" )
`MPRco( TOXP           ,EOT1           ,"m"           ,0.1e-9      ,inf         ,"Physical oxide thickness" )

// Velocity Saturation Model
`MPRnb( VSAT           ,85000          ,"m/s"                                   ,"Saturation Velocity" )
`MPRnb( AVSAT          ,0.0            ,"m/s"                                   ,"Saturation velocity term in the saturation region for short channel devices" )
`MPRex( BVSAT          ,100.0e-9       ,"m"           ,0.0                      ,"Saturation velocity coefficient in the saturation region for short channel devices" )
`MPRnb( VSAT1          ,VSAT           ,"m/s"                                   ,"Velocity Saturation parameter" )
`MPRnb( AVSAT1         ,AVSAT          ,"m/s"                                   ,"Saturation velocity term in the linear region for short channel devices" )
`MPRex( BVSAT1         ,BVSAT          ,"m"           ,0.0                      ,"Saturation velocity coefficient in the linear region for short channel devices" )
`MPRnb( VSATCV         ,VSAT           ,"m/s"                                   ,"Velocity Saturation parameter for CV" )
`MPRnb( AVSATCV        ,AVSAT          ,"m/s"                                   ,"Saturation velocity term in the saturation region for short channel C-V" )
`MPRex( BVSATCV        ,BVSAT          ,"m"           ,0.0                      ,"Saturation velocity coefficient in the saturation region for short channel C-V" )
`MPRcz( DELTAVSAT      ,1.0            ,"m/s"                                   ,"Velocity saturation parameter" )
`MPRnb( KSATIV         ,1.0            ,""                                      ,"Parameter for strong inversion regime for long channel Vdsat" )
`MPRnb( KSUBIV         ,1.0            ,""                                      ,"Parameter for weak inversion regime for long channel Vdsat" )
`MPRnb( KSATIVB        ,0.0            ,""                                      ,"Parameter for strong inversion regime for long channel Vdsat" )
`MPRnb( MEXP           ,4.0            ,""                                      ,"Smoothing function factor for Vdsat" )
`MPRnb( AMEXP          ,0.0            ,""                                      ,"Smoothing function factor for Vdsat in short channel devices" )
`MPRnb( BMEXP          ,1.0            ,"m"                                     ,"Smoothing function coefficient for Vdsat in short channel devices" )
`MPRnb( PTWG           ,0.0            ,"V^-2"                                  ,"Correction factor for velocity saturation" )
`MPRnb( APTWG          ,0.0            ,"V^-2"                                  ,"Correction factor for velocity saturation in short channel devices" )
`MPRex( BPTWG          ,100.0e-9       ,"m"           ,0.0                      ,"Coefficient for correction factor for velocity saturation in short channel devices" )
`MPRnb( AT             ,-1.56e-3       ,"/K"                                    ,"Saturation Velocity Temperature Coefficient" )
`MPRnb( ATL            ,0.0            ,"m"                                     ,"Length scaling for AT" )
`MPRnb( TMEXP          ,0.0            ,""                                      ,"Temperature Coefficient for smoothing function factor for Vdsat" )
`MPRnb( PTWGT          ,0.004          ,"/K"                                    ,"PTWG Temperature Coefficient" )
`MPRnb( PTWGB          ,0.0            ,"V^-3"                                  ,"Parameter for back gate bias sensitivity in PTWGB" )
`MPRnb( PTWGB2         ,0.0            ,"V^-3"                                  ,"Parameter for back gate bias sensitivity in PTWGB" )
`MPRnb( APTWGB         ,0.0            ,"V^-3"                                  ,"Parameter for back gate bias sensitivity in PTWGB for short channel devices" )
`MPRex( BPTWGB         ,100.0e-9       ,"m"           ,0.0                      ,"Parameter for back gate bias sensitivity in PTWGB for short channel devices" )
`MPRnb( APTWGB2        ,0.0            ,"V^-3"                                  ,"Parameter for back gate bias sensitivity in PTWGB for short channel devices" )
`MPRex( BPTWGB2        ,100.0e-9       ,"m"           ,0.0                      ,"Parameter for back gate bias sensitivity in PTWGB for short channel devices" )
`MPRnb( VSATB          ,0.0            ,"V^-1"                                  ,"Saturation velocity parameter for back gate bias dependence on mobility at high Vds" )
`MPRnb( ATB            ,0.0            ,"/K"                                    ,"Back bias sensitivity parameter for saturation velocity temperature coefficient" )
`MPRnb( ATBL           ,0.0            ,"m"                                     ,"Length scaling for ATB" )
`MPRnb( AVSATB         ,0.0            ,"V^-1"                                  ,"Saturation velocity parameter for back gate bias dependence on mobility at high Vds for short channel devices" )
`MPRex( BVSATB         ,100.0e-9       ,"m"           ,0.0                      ,"Saturation velocity parameter for back gate bias dependence on mobility at high Vds for short channel devices" )
`MPRco( DVSATCLAMP     ,0.01           ,"m"           ,0.01        ,inf         ,"Minimum clamp on Dvsat" )

// Mobility Model
`MPRex( U0             ,0.03           ,"m^2/(V*s)"   ,0.0                      ,"Low Field Mobility at front gate" )
`MPRnb( ETAMOB         ,2.0            ,""                                      ,"Effective field parameter" )
`MPRnb( UP             ,0.0            ,"(um)^LPA"                              ,"Mobility L coefficient" )
`MPRnb( LPA            ,1.0            ,""                                      ,"Mobility L power coefficient" )
`MPRnb( UA             ,0.3            ,"(MV/cm)^(-EU)"                         ,"Phonon / surface roughness scattering at front gate" )
`MPRnb( AUA            ,0.0            ,"(MV/cm)^(-EU)"                         ,"Phonon / surface roughness scattering for short channel devices" )
`MPRex( BUA            ,100.0e-9       ,"m"           ,0.0                      ,"Phonon / surface roughness scattering for short channel devices" )
`MPRnb( EU             ,2.5            ,"cm/MV"                                 ,"Phonon / surface roughness scattering at front gate" )
`MPRnb( AEU            ,0.0            ,"cm/MV"                                 ,"Phonon / surface roughness scattering for short channel devices" )
`MPRex( BEU            ,100.0e-9       ,"m"           ,0.0                      ,"Phonon / surface roughness scattering for short channel devices" )
`MPRnb( UC             ,0.0            ,"(1/V)*(MV/cm)^(-EU)"                   ,"Parameter for back gate bias dependence on mobility at low Vds at front gate" )
`MPRnb( AUC            ,0.0            ,"(1/V)*(MV/cm)^(-EU)"                   ,"Parameter for back gate bias dependence on mobility at low Vds for short channel devices" )
`MPRex( BUC            ,100.0e-9       ,"m"           ,0.0                      ,"Parameter for back gate bias dependence on mobility at low Vds for short channel devices" )
`MPRnb( UD             ,0.0            ,""                                      ,"Coulomb scattering (experimental) at front gate" )
`MPRnb( AUD            ,0.0            ,""                                      ,"Coulomb scattering for short channel devices" )
`MPRex( BUD            ,50.0e-9        ,"m"           ,0.0                      ,"Coulomb scattering for short channel devices" )
`MPRnb( UDB            ,0.0            ,"V^-1"                                  ,"Back bias sensitivity on Coulomb scattering (experimental) at front gate" )
`MPRnb( AUDB           ,0.0            ,"V^-1"                                  ,"Back bias sensitivity on Coulomb scattering (experimental) for short channel devices" )
`MPRex( BUDB           ,50.0e-9        ,"m"           ,0.0                      ,"Back bias sensitivity on Coulomb scattering (experimental) for short channel devices" )
`MPRco( DMOBCLAMP      ,0.01           ,"m"           ,0.01        ,inf         ,"Minimum clamp on Dmob" )
`MPRnb( UCS            ,1.0            ,""                                      ,"Coulomb scattering (experimental) at front gate" )
`MPRnb( UTE            ,0.0            ,""                                      ,"Mobility Temperature coefficient" )
`MPRnb( UTL            ,-1.5e-3        ,""                                      ,"Mobility Temperature coefficient" )
`MPRnb( UA1            ,1.032e-3       ,""                                      ,"Mobility Temperature coefficient for UA" )
`MPRnb( UC1            ,0.0            ,""                                      ,"Mobility Temperature coefficient for UC" )
`MPRnb( UD1            ,0.0            ,""                                      ,"Mobility Temperature coefficient" )
`MPRnb( UCSTE          ,-4.775e-3      ,""                                      ,"Mobility Temperature coefficient" )
`MPRcc( CHARGEWF       ,0.0            ,""            ,-1.0        ,1.0         ,"Average Channel Charge Weighting Factor, +1:source-side, 0:middle, -1:drain-side" )
`MPRnb( EUB            ,0.0            ,"V^-1"                                  ,"Back gate sensitivity on Phonon/surface roughness scattering at front gate" )
`MPRnb( AEUB           ,0.0            ,"V^-1"                                  ,"Back gate sensitivity on Phonon/surface roughness scattering for short channel devices" )
`MPRex( BEUB           ,100.0e-9       ,"m"            ,0.0                     ,"Back gate sensitivity on Phonon/surface roughness scattering for short channel devices" )
`MPRnb( U02            ,0.03           ,"m^2/(V*s)"                             ,"Low Field Mobility at back gate" )
`MPRnb( UA2            ,0.3            ,"(MV/cm)^(-EU2)"                        ,"Phonon/surface roughness scattering at back gate" )
`MPRnb( AUA2           ,0.0            ,"(MV/cm)^(-EU2)"                        ,"Phonon/surface roughness scattering at back gate for short channel devices" )
`MPRex( BUA2           ,100.0e-9       ,"m"           ,0.0                      ,"Phonon/surface roughness scattering at back gate for short channel devices" )
`MPRnb( EU2            ,2.5            ,"cm/MV"                                 ,"Phonon/surface roughness scattering at back gate" )
`MPRnb( AEU2           ,0.0            ,"cm/MV"                                 ,"Phonon/surface roughness scattering at back gate for short channel devices" )
`MPRex( BEU2           ,100.0e-9       ,"m"           ,0.0                      ,"Phonon/surface roughness scattering at back gate for short channel devices" )
`MPRnb( UC2            ,0.0            ,"(1/V)*(MV/cm)^(-EU2)"                  ,"Parameter for back gate bias dependence on mobility at low Vds at back gate" )
`MPRnb( AUC2           ,0.0            ,"(1/V)*(MV/cm)^(-EU2)"                  ,"Parameter for back gate bias dependence on mobility at low Vds at back gate for short channel devices" )
`MPRex( BUC2           ,100.0e-9       ,"m"           ,0.0                      ,"Parameter for back gate bias dependence on mobility at low Vds at back gate for short channel devices" )
`MPRnb( UD2            ,0.0            ,""                                      ,"Coulomb scattering (Experimental) at back gate" )
`MPRnb( AUD2           ,0.0            ,""                                      ,"Coulomb scattering (Experimental) for short channel devices" )
`MPRex( BUD2           ,50.0e-9        ,"m"           ,0.0                      ,"Coulomb scattering (Experimental) for short channel devices" )
`MPRnb( UDB2           ,0.0            ,"V^-1"                                  ,"Back bias sensitivity on Coulomb scattering (experimental) at back gate" )
`MPRnb( AUDB2          ,0.0            ,"V^-1"                                  ,"Back bias sensitivity on Coulomb scattering (experimental) at back gate for short channel devices" )
`MPRex( BUDB2          ,50.0e-9        ,"m"           ,0.0                      ,"Back bias sensitivity on Coulomb scattering (experimental) at back gate for short channel devices" )
`MPRnb( UCS2           ,1.0            ,""                                      ,"Coulomb scattering (Experimental) at back gate" )
`MPRnb( EUB2           ,0.0            ,"V^-1"                                  ,"Back gate sensitivity on phonon/surface roughness scattering at back gate" )
`MPRnb( AEUB2          ,0.0            ,"V^-1"                                  ,"Back gate sensitivity on phonon/surface roughness scattering at back gate for short channel devices" )
`MPRex( BEUB2          ,100.0e-9       ,"m"           ,0.0                      ,"Back gate sensitivity on phonon/surface roughness scattering at back gate for short channel devices" )
`MPRnb( ETAMOB2        ,2.0            ,""                                      ,"Effective field parameter at back gate" )
`MPRnb( UP2            ,0.0            ,"(um)^LPA2"                             ,"Mobility L coefficient at back gate" )
`MPRnb( LPA2           ,1.0            ,""                                      ,"Mobility L power coefficient at back gate" )
`MPRcc( CHARGEWF2      ,0.0            ,""            ,-1.0        ,1.0         ,"Average Channel Charge Weighting Factor, +1:source-side, 0:middle, -1:drain-side" )

// Access Resistance Model
`MPRcz( RDSWMIN        ,0.0            ,"ohm*um^WR"                             ,"RDSMOD = 0 S/D extension resistance per unit width at high Vgs" )
`MPRcz( RDSW           ,100.0          ,"ohm*um^WR"                             ,"RDSMOD = 0 zero bias S/D extension resistance per unit width" )
`MPRnb( ARDSW          ,0.0            ,"ohm*um^WR"                             ,"RDSMOD = 0 zero bias S/D extension resistance per unit width for short channel devices" )
`MPRex( BRDSW          ,100.0e-9       ,"m"           ,0.0                      ,"RDSMOD = 0 zero bias S/D extension resistance per unit width for short channel devices" )
`MPRcz( RSWMIN         ,0.0            ,"ohm*um^WR"                             ,"RDSMOD = 1 source extension resistance per unit width at high Vgs" )
`MPRcz( RSW            ,50.0           ,"ohm*um^WR"                             ,"RDSMOD = 1 zero bias source extension resistance per unit width" )
`MPRnb( ARSW           ,0.0            ,"ohm*um^WR"                             ,"pre-exponential coefficient for RSW" )
`MPRex( BRSW           ,100.0e-9       ,"m"           ,0.0                      ,"exponential coefficient for RSW" )
`MPRcz( RDWMIN         ,RSWMIN         ,"ohm*um^WR"                             ,"RDSMOD = 1 drain extension resistance per unit width at high Vgs" )
`MPRcz( RDW            ,RSW            ,"ohm*um^WR"                             ,"RDSMOD = 1 zero bias drain extension resistance per unit width" )
`MPRnb( ARDW           ,ARSW           ,"ohm*um^WR"                             ,"RDSMOD = 1 zero bias drain extension resistance per unit width for short channel devices" )
`MPRex( BRDW           ,BRSW           ,"m"           ,0.0                      ,"RDSMOD = 1 zero bias drain extension resistance per unit width for short channel devices" )
`MPRnb( PRWG           ,0              ,"V^-1"                                  ,"Gate bias dependence of source/drain extension resistance" )
`MPRnb( PRWB           ,0              ,"V^-1"                                  ,"Back gate bias dependence of source/drain extension resistance" )
`MPRnb( WR             ,1.0            ,""                                      ,"W dependence parameter of S/D extension resistance" )
`MPRnb( PRT            ,0.001          ,"K^-1"                                  ,"Series Resistance Temperature coefficient" )
`MPRcz( RSC            ,0              ,"ohm"                                   ,"Source contact resistance" )
`MPRcz( RDC            ,RSC            ,"ohm"                                   ,"Drain contact resistance" )
`MPRnb( TRS            ,0              ,"K^-1"                                  ,"TEMP Dependence of Source contact resistance" )
`MPRnb( TRD            ,TRS            ,"K^-1"                                  ,"TEMP Dependence of Drain contact resistance" )
// Minimum resistance value
`MPRcz( minr          ,$simparam("minr", 1.0e-3) ,"ohm"                         ,"minr is the value below which the simulator expects elimination of source/drain resistance and it will improve simulation efficiency without significantly altering the results.")

// DIBL Model
`MPRnb( PDIBL1         ,1.30           ,""                                      ,"DIBL Output Conductance parameter" )
`MPRnb( PDIBL2         ,2.0e-4         ,""                                      ,"DIBL Output Conductance parameter" )
`MPRnb( DROUT          ,1.06           ,""                                      ,"L dependence of DIBL effect on Rout" )
`MPRnb( PVAG           ,1.0            ,""                                      ,"Vgs dependence on early voltage" )

// Channel Length Modulation Effect
`MPRnb( PCLM           ,0.013          ,""                                      ,"Channel Length Modulation (CLM) parameter" )
`MPRnb( APCLM          ,0.0            ,""                                      ,"Channel Length Modulation (CLM) parameter for short channel devices" )
`MPRex( BPCLM          ,100.0e-9       ,"m"           ,0.0                      ,"Channel Length Modulation (CLM) parameter for short channel devices" )
`MPRnb( PCLMG          ,0.0            ,""                                      ,"Gate bias dependent parameter for channel Length Modulation (CLM)" )
`MPRnb( PCLMCV         ,0.013          ,""                                      ,"Channel Length Modulation (CLM) parameter for C-V" )

// Geometry dependent Source/Drain Resistance RGEOMOD=0
`MPRcz( RSHS           ,0.0            ,"ohm"                                   ,"Source-side sheet resistance" )
`MPRcz( RSHD           ,RSHS           ,"ohm"                                   ,"Drain-side sheet resistance" )

// Gate Tunneling Current from Gate to Channel (Igc)
`MPRnb( AIGBINV        ,1.11e-2        ,"((F*s^2/g)^0.5)*m^-1"                  ,"Parameter for Igb in inversion" )
`MPRnb( BIGBINV        ,9.49e-4        ,"((F*s^2/g)^0.5)*(m*V)^-1"              ,"Parameter for Igb in inversion" )
`MPRnb( CIGBINV        ,6.0e-3         ,"V^-1"                                  ,"Parameter for Igb in inversion" )
`MPRnb( EIGBINV        ,1.1            ,"V"                                     ,"Parameter for Igb in inversion" )
`MPRnb( NIGBINV        ,3.0            ,""                                      ,"Parameter for Igb in inversion" )
`MPRnb( AIGBACC        ,1.36e-2        ,"((F*s^2/g)^0.5)*m^-1"                  ,"Parameter for Igb in accumulation" )
`MPRnb( BIGBACC        ,1.71e-3        ,"((F*s^2/g)^0.5)*(m*V)^-1"              ,"Parameter for Igb in accumulation" )
`MPRnb( CIGBACC        ,7.5e-2         ,"V^-1"                                  ,"Parameter for Igb in accumulation" )
`MPRnb( NIGBACC        ,1.0            ,""                                      ,"Parameter for Igb in accumulation" )
`MPRnb( AIGC           ,1.36e-2        ,"((F*s^2/g)^0.5)*m^-1"                  ,"Parameter for Igc in inversion" )
`MPRnb( BIGC           ,1.71e-3        ,"((F*s^2/g)^0.5)*(m*V)^-1"              ,"Parameter for Igc in inversion" )
`MPRnb( CIGC           ,0.075          ,"V^-1"                                  ,"Parameter for Igc in inversion" )
`MPRnb( PIGCD          ,1.0            ,""                                      ,"Parameter for Igc partition" )
`MPRnb( DIGC           ,1.0            ,""                                      ,"Parameter for Igc in inversion" )

// Gate Tunneling Current from Gate to S/D (Igs and Igd)
`MPRnb( AIGS           ,1.36e-2        ,"((F*s^2/g)^0.5)*m^-1"                  ,"Parameter for Igs, Igd" )
`MPRnb( BIGS           ,1.71e-3        ,"((F*s^2/g)^0.5)*(m*V)^-1"              ,"Parameter for Igs, Igd" )
`MPRnb( CIGS           ,0.075          ,"V^-1"                                  ,"Parameter for Igs, Igd" )
`MPRcz( DLCIGS         ,0.0            ,"m"                                     ,"Delta L for Igs model" )
`MPRcz( DLCIGD         ,DLCIGS         ,"m"                                     ,"Delta L for Igd model" )
`MPRnb( AIGD           ,AIGS           ,"((F*s^2/g)^0.5)*m^-1"                  ,"Parameter for Igd in inversion" )
`MPRnb( BIGD           ,BIGS           ,"((F*s^2/g)^0.5)*(m*V)^-1"              ,"Parameter for Igd in inversion" )
`MPRnb( CIGD           ,CIGS           ,"V^-1"                                  ,"Parameter for Igd in inversion" )
`MPRoz( TOXREF         ,1.2e-9         ,"m"                                     ,"Target tox value" )
`MPRnb( NTOX           ,1.0            ,""                                      ,"Exponent for Tox ratio" )
`MPRnb( POXEDGE        ,1.0            ,""                                      ,"Factor for the gate edge Tox" )
`MPRnb( DIGS           ,1.0            ,""                                      ,"Parameter for Igs, Igd" )
`MPRnb( DIGD           ,DIGS           ,""                                      ,"Parameter for Igd in inversion" )

// Gate-Induced Source/Drain Leakage
`MPRnb( AGIDL          ,6.055e-12      ,"mho"                                   ,"Pre-exponential coeff. for GIDL" )
`MPRnb( BGIDL          ,0.3e9          ,"V/m"                                   ,"Exponential coeff. for GIDL" )
`MPRnb( EGIDL          ,0.2            ,"V"                                     ,"Band bending parameter for GIDL" )
`MPRnb( PGIDL          ,1.0            ,""                                      ,"Exponent of electric field for GIDL" )
`MPRnb( VBGIDL         ,1.0            ,""                                      ,"Back gate correction factor for GIDL" )
`MPRnb( VBEGIDL        ,0.5            ,"V"                                     ,"Back band bending parameter for GIDL" )
`MPRnb( AGISL          ,AGIDL          ,"mho"                                   ,"Pre-exponential coeff. for GISL" )
`MPRnb( BGISL          ,BGIDL          ,"V/m"                                   ,"Exponential coeff. for GISL" )
`MPRnb( EGISL          ,EGIDL          ,"V"                                     ,"Band bending parameter for GISL" )
`MPRnb( PGISL          ,PGIDL          ,""                                      ,"Exponent of electric field for GISL" )
`MPRnb( VBGISL         ,VBGIDL         ,""                                      ,"Back gate correction factor for GISL" )
`MPRnb( VBEGISL        ,VBEGIDL        ,"V"                                     ,"Back band bending parameter for GISL" )

// Impact Ionization Current
`MPRnb( ALPHA0         ,0.0            ,"m/V"                                   ,"First parameter of Iii" )
`MPRnb( ALPHA1         ,0.0            ,"V^-1"                                  ,"L scaling parameter of Iii" )
`MPRnb( BETA0          ,0.0            ,"V^-1"                                  ,"Vds dependent parameter of Iii" )

// Overlap Cap and Fringing Cap
`MPRnb( LOVS           ,0.0            ,"m"                                     ,"Overlap length for fg/s fg/d overlap" )
`MPRnb( LOVD           ,LOVS           ,"m"                                     ,"Overlap length for fg/s fg/d overlap" )
`MPRcz( CFS            ,0.0            ,"F/m"                                   ,"Outer Fringe Cap" )
`MPRcz( CFD            ,CFS            ,"F/m"                                   ,"Outer Fringe Cap" )
`MPRcz( CGSL           ,0.0            ,"F/m"                                   ,"Overlap capacitance between gate and lightly-doped source region" )
`MPRcz( CGDL           ,CGSL           ,"F/m"                                   ,"Overlap capacitance between gate and lightly-doped drain region" )
`MPRco( CKAPPAS        ,0.6            ,"V"           ,0.02        ,inf         ,"Coefficient of bias-dependent overlap capacitance for the source side" )
`MPRco( CKAPPAD        ,CKAPPAS        ,"V"           ,0.02        ,inf         ,"Coefficient of bias-dependent overlap capacitance for the drain side" )
`MPRnb( CSDBGSW        ,0.0            ,"F/m"                                   ,"Source/drain sidewall fringing capacitance per unit length" )
`MPRnb( PCOVBS0        ,0.0            ,"V"                                     ,"Back-gate dependent overlap capacitance clamping shift voltage for the source side" )
`MPRnb( PCOVBS1        ,0.0            ,""                                      ,"Parameter of back-gate dependent overlap capacitance for the source side" )
`MPRnb( PCOVBD0        ,PCOVBS0        ,"V"                                     ,"Back-gate dependent overlap capacitance clamping shift voltage for the drain side" )
`MPRnb( PCOVBD1        ,PCOVBS1        ,""                                      ,"Parameter of back-gate dependent overlap capacitance for the drain side" )

// Back Gate Biasing Effect, Gamma = d_Vth / d_Vbg
// P-well
`MPRnb( KBG0PW         ,1.0            ,""                                      ,"Length dependence of substrate factor" )
`MPRnb( KBG1PW         ,0.0            ,""                                      ,"Length dependence of substrate factor" )
`MPRnb( KBG2PW         ,-1.0           ,""                                      ,"Length dependence of substrate factor" )
`MPRnb( DBGPW          ,0.12           ,""                                      ,"Length dependence of substrate factor" )
`MPRnb( BPFACTORPW     ,0.0            ,""                                      ,"Back-plane (BP) effect, 1 means no BP" )
`MPRnb( VKNEE1PW       ,0.0            ,"V"                                     ,"Back gate voltage at which the substrate depletion below the BOX starts" )
`MPRco( VKNEE2PW       ,1.0            ,"V"           ,0.0         ,inf         ,"Maximum potential drop below the BOX" )

// N-well
`MPRnb( KBG0NW         ,KBG0PW         ,""                                      ,"Length dependence of body factor" )
`MPRnb( KBG1NW         ,KBG1PW         ,""                                      ,"Length dependence of body factor" )
`MPRnb( KBG2NW         ,KBG2PW         ,""                                      ,"Length dependence of body factor" )
`MPRnb( DBGNW          ,DBGPW          ,""                                      ,"Length dependence of body factor" )
`MPRnb( BPFACTORNW     ,BPFACTORPW     ,""                                      ,"Back-plane (BP) effect, 1 means no BP" )
`MPRnb( VKNEE1NW       ,VKNEE1PW       ,"V"                                     ,"Back gate voltage at which the substrate depletion below the BOX starts" )
`MPRco( VKNEE2NW       ,VKNEE2PW       ,"V"           ,0.0         ,inf         ,"Maximum potential drop below the BOX" )

// Flicker Noise
`MPRoc( EF             ,1.0            ,""            ,0.0         ,2.0         ,"Flicker noise frequency exponent" )
`MPRoz( EM             ,4.1e7          ,"V/m"                                   ,"Flicker noise parameter" )
`MPRoz( NOIA           ,6.25e39        ,"eV^-1* s^1-EF *m^-3"                   ,"Flicker noise parameter" )
`MPRoz( NOIB           ,3.125e24       ,"eV^-1* s^1-EF *m^-1"                   ,"Flicker noise parameter" )
`MPRoz( NOIC           ,8.75e7         ,"eV^-1* s^1-EF *m"                      ,"Flicker noise parameter" )
`MPRoz( NOIA2          ,NOIA           ,"eV^-1* s^1-EF *m^-3"                   ,"Noise parameter for FNMOD=1" )
`MPRoz( SMOOTH         ,2              ,""                                      ,"Smoothing Parameter" )
`MPRoz( MPOWER         ,1.2            ,""                                      ,"Sub-threshold to strong inversion transition slope Parameter" )
`MPRoz( QSREF          ,50m            ,"C*m^-2"                                ,"Charge at threshold condition" )

// Thermal Noise
`MPRcz( NTNOI          ,1.0            ,""                                      ,"Thermal noise parameter" )
`MPRnb( LINTNOI        ,0.0            ,"m"                                     ,"Lint offset for flicker noise calculation" )

// Correlated thermal noise
`MPIcc( TNOIMOD        ,0              ,""            ,0           ,1           ,"0: Charge-based, 1: Correlated thermal noise model")
`MPRcz( RNOIA          ,0.5774         ,""                                      ,"Empirical parameter for Sid level")
`MPRnb( TNOIA          ,0.0            ,"/m"                                    ,"Empirical parameter for Leff trend of Sid")
`MPRcz( RNOIB          ,0.3652         ,""                                      ,"Empirical parameter for Sig level")
`MPRnb( TNOIB          ,0.0            ,"/m"                                    ,"Empirical parameter for Leff trend of Sig")
`MPRcz( RNOIC          ,0.3953         ,""                                      ,"Empirical parameter for correlation coefficient")
`MPRnb( TNOIC          ,0.0            ,"/m"                                    ,"Empirical parameter for Leff trend of correlation coefficient")
`MPRcz( RNOIK          ,0.0            ,""                                      ,"Empirical parameter for Sid level at low Ids")
`MPRnb( TNOIK          ,0.0            ,"/m"                                    ,"Empirical parameter for Leff trend of Sid at low Ids")
`MPRcz( TNOIK2         ,0.1            ,""                                      ,"Empirical parameter for sensitivity of RNOIK")

// Temperature Effect
`MPRoo( TNOM           ,27.0           ,"Celsius"     ,-273.15     ,inf         ,"Temperature at which the model is extracted" )
`MPRnb( TMAXC          ,400.0          ,"Celsius"                               ,"Maximum Device Temperature" )
`MPRnb( TBGASUB        ,7.02e-4        ,"eV/K"                                  ,"Bandgap Temperature Coefficient" )
`MPRnb( TBGBSUB        ,1108.0         ,"K"                                     ,"Bandgap Temperature Coefficient" )
`MPRnb( KT1            ,0.0            ,"V"                                     ,"Vth Temperature Coefficient" )
`MPRnb( KT1L           ,0.0            ,"V*m"                                   ,"Vth Temperature L Coefficient" )
`MPRnb( KT2            ,0.0            ,""                                      ,"Vth Temperature Vbg Coefficient" )
`MPRnb( KT2L           ,0.0            ,"m"                                     ,"Vbg Temperature L Coefficient" )
`MPRnb( IIT            ,-0.5           ,""                                      ,"Impact Ionization Temperature Dependence" )
`MPRnb( TGIDL          ,-0.003         ,"K^-1"                                  ,"GIDL Temperature Dependence" )
`MPRnb( TGISL          ,TGIDL          ,"K^-1"                                  ,"GISL Temperature Dependence" )
`MPRnb( IGT            ,2.5            ,""                                      ,"Gate Current Temperature Dependence" )
`MPRnb( TETA0          ,0.0            ,"K^-1"                                  ,"Temperature Dependence for DIBL effects" )

// Self-Heating
`MPRcz( RTH0           ,0.01           ,"ohm*m*K/W"                             ,"Thermal resistance" )
`MPRcz( CTH0           ,1.0e-5         ,"W*s/m/K"                               ,"Thermal capacitance" )
`MPRcz( WTH0           ,0.0            ,"m"                                     ,"Width dependence coefficient for Rth and Cth" )

`MPRnb( XGW            ,0.0            ,"m"                                     ,"Distance from gate contact center to device edge" )
`MPRoo( XGL            ,0.0            ,"m"           ,-inf        ,L + XL      ,"Variation in Ldrawn" )
`MPIcc( NGCON          ,1              ,""            ,1           ,2           ,"Number of gate contacts" )
`MPRcz( RSHG           ,0.1            ,"ohm"                                   ,"Gate sheet resistance" )

// For NQSMOD = 1, Set XRCRG1 = 0 to turn off NQS gate resistance
`MPRnb( XRCRG1         ,12.0           ,""            ,"Parameter for Rg in NQSMOD = 1" )
`MPRnb( XRCRG2         ,1.0            ,""            ,"Parameter for Rg in NQSMOD = 1" )

// Reliability Effects
`BPRcz( DELHCI     ,0.0            ,""                                      ,"HCI degradation parameter. 0: turns off HCI aging model" )
`MPRnb( HCIDB0     ,0.0            ,""                                      ,"HCI parameter for Vdbg dependence" )
`MPRnb( HCIDB1     ,0.0            ,"V^-1"                                  ,"HCI parameter for Vdbg dependence" )
`MPRnb( HCIU0      ,0.0            ,"m^2/(Vs)"                              ,"HCI aging parameter for U0" )
`MPRnb( HCIDU0     ,0.0            ,"m^2/(Vs)"                              ,"HCI aging parameter for U0" )
`MPRnb( HCIUD      ,0.0            ,""                                      ,"HCI aging parameter for UD" )
`MPRnb( HCIDUD     ,0.0            ,""                                      ,"HCI aging parameter for UD" )
`MPRnb( HCIUCS     ,0.0            ,""                                      ,"HCI aging parameter for UCS" )
`MPRnb( HCIDUCS    ,0.0            ,""                                      ,"HCI aging parameter for UCS" )
`MPRnb( HCIVSAT    ,0.0            ,"m/s"                                   ,"HCI aging parameter for VSAT" )
`MPRnb( HCIDVSAT   ,0.0            ,"m/s"                                   ,"HCI aging parameter for VSAT" )
`MPRnb( HCICIT     ,0.0            ,"F/m^2"                                 ,"HCI aging parameter for CIT" )
`MPRnb( HCIDCIT    ,0.0            ,"F/m^2"                                 ,"HCI aging parameter for CIT" )
`MPRnb( HCIVTH     ,0.0            ,"V"                                     ,"HCI aging parameter for threshold voltage" )
`MPRnb( HCIDVTH    ,0.0            ,"V"                                     ,"HCI aging parameter for threshold voltage" )

// Binning Parameters
`include "bsimimg_binning.include"

// *****************
// **  Variables  **
// *****************

// Common Variables
real Lnew, LeffCV, Leff, Weff, WeffCV, Wnew, L_LLN, W_LWN, LW_LLN_LWN, dLIV, L_WLN, W_WWN, LW_WLN_WWN, dWIV, dLCV, dWCV;
real epssi, cox1, cox1P, cox2, csi, epsratio;
real vfgs, vbgs, vbgd, vbgx, vds, sigvds, vbgxpos;
real vgs_noswap, vds_noswap, vgd_noswap, vbgs_noswap, vbgd_noswap;
real T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11;
real qia, qia2, qba, dqi;
real phib, phisub, deltaphi1, deltaphi2;
real Eg, Vtm;
real beta;
real wf, wr;
real qb0;
real dvth_nbody;
real tmp, QMTCENCV_i, Tcen0, Tcen, coxeff;
real ETAQM_i, QM0_i, PQM_i;

// Terminal Voltage Conditioning Variables
real vgfb1, vgfb2, vgfb1eff, vgfb2eff;
real vdsx, symmetry_factor;

// Short Channel Effects
real scl, sclm, sclf, teff, temp;
real vbi, nVtm, dvth_dibl, dvth_vtroll, dvth_rsce, dvth_dsc, dvth_all, phist;
real Theta_SCE, Theta_RSCE, Theta_DIBL;

// DITS Model parameters
real Theta_DITS, DVTP0_i, DVTP1_i;

// Lateral Non-uniform Doping Effect
real Mnud;

// Temperature Effects
real Tnom, TRatio, delTemp, delTemp0;
real PhiRef, PhiSD, ni;
real dvth_temp, dvth_temp0;
real BETA0_t, BGIDL_t, BGISL_t, igtemp, ETA0_t;
real K0SISAT_t;

// Drain Saturation Voltage
real qis, qid, qbs, Dmobs, Vdseff;
real eta_mu, eta_mu_cv, Eeffm, Eeffm2, Eeffm_cv, Dmob, Dmob_cv, utotal;
real UA_t, UC_t, UCS_t, UD_t, U0_t, Eeffs, Eeffs2, EeffFactor;
real Dr, WeffWRFactor;
real RSourceGeo, RDrainGeo;
real RDSWMIN_i, RDWMIN_i, RSWMIN_i;
real UDB_i, UDB2_i;
real w1, w2, ueff1, ueff2, eta_mu2, EeffFactor2, qib2;
real Rdrain, Rsource;
real gspr, gdpr;
real rdstemp, Rdsi, Rdss, RSC0, RDC0, RSC0_t, RDC0_t;
real DIBLfactor, PVAGfactor, diffVds, VaDIBL, Vgst2Vtm, Moc, Mclm, MclmCV;
real Dvsat, Vdsat, inv_MEXP, Lterm, Lterm0;
real VSAT_t,VSATB_t,VSAT1_t, VSATCV_t, MEXP_t, Esat, EsatL, EsatCV, EsatCVL, Esat1, Esat1L;
real K0_t, K0SI_t;
real WVCox, Ta, Tb, Tc;
real Xsat;
real PTWG_t;

// Gate Current
real Vaux_Igbinv, igbinv, igsd_mult, igsd_mult0, igbs, igbd;
real Voxacc, Vaux_Igbacc, vfbzb, igbacc;
real igcs, igcd, igc0, Vdseffx, T1_exp;
real igisl, igidl, vfbsd, igs, igd, vfgs_eff, vfgd_eff;
real Aechvb, Bechvb, Toxratio, Toxratioedge;
real vgbg, phifs;

// Impact Ionization Current
real Iii;

// I-V Variables
integer devsign, welsign;
real ids, ids0, ids0_ov_dqi;

// C-V Variables
real qs, qd, qfg, qbg;
real IMGTOXP;
real qsi, qdi, qfgi, qbgi;

// Parasitic Capacitances
real qfgs_parasitic, qfgd_parasitic, qfgs_ov, qfgs_of, qfgd_ov, qfgd_of;
real vfgs_ov, vfgd_ov;
real vgd_ov_noswap, vgs_ov_noswap;
real csbox, cdbox, Qsbg, Qdbg;
real vfbsd_bg;

// Back-gate Biasing Effects
real kvbg, dvth_vbg, gamma0, vsubdep0, vsubdep, vknee1, vknee2, bpfactor;

// Flicker Noise
real LINTNOI_i;
real NOIA2_i, MPOWER_i, QSREF_i;
real litl, Esatnoi, Leffnoi, Leffnoisq, DelClm;
real NOIAeff, N0, Nl, Nstar, Ssi, Swi, FNPowerAt1Hz;

// Thermal Noise
real qinv;
real Gtnoi, sid;
real Nt;

// Correlated thermal noise
real noiBeta, noiTheta, noiCorr, noiLowId, noiEta, noiWI, noiGd0, Dvsat3;
real T5_2, T5_3, T5_4, T7_2, T7_3, T7_4, T7_5;
real etaiv0, ids0_ov_dqi0, Rdsi0, Eeffm0;
real Mnud0, Mob0, Dmob0, Dvsat0, Dr0;
real gamma1, gamma2, gamma;
real delta1, delta2, delta3, delta_therm;
real epsilon1, epsilon2, epsilon;
real ctnoi, sigrat;
real q0, rc;

// Self-Heating
real gth, cth;
real DevTemp, TMAXK, DevTemp0;

// Gate Resistances
real Grgeltd;

// NQS Gate Resistance
real gcrg, XRCRG1_i, XRCRG2_i;
real IdsovVds;

// Aging effects
real dvth_hci, exp_hci;

// Binning
real Inv_L, Inv_W, Inv_WL;
real RDSW_i, RDW_i, RSW_i;
real PRWG_i, PRWB_i, WR_i;
real PHIG1_i, PHIG2_i;
real NSD_i, NBODY_i;
real CIT_i, CDSC_i, CDSCD_i, CBGCBG_i;
real BPFACTORPW_i, VKNEE1PW_i, VKNEE2PW_i, DBGPW_i, KBG0PW_i, KBG1PW_i, KBG2PW_i;
real BPFACTORNW_i, VKNEE1NW_i, VKNEE2NW_i, DBGNW_i, KBG0NW_i, KBG1NW_i, KBG2NW_i;
real DSC0_i, DSC1_i, ASCL_i, BSCL_i;
real DVT0_i, DVT1_i, PHIN_i;
real ETA0_i, ETA1_i, ETAB_i, DSUB_i, K1RSCE_i, LPE0_i;
real K0_i, K01_i, K0SI_i, K0SI1_i, MEXP_i;
real PTWG_i, PTWGB_i, PTWGB2_i, PTWGT_i;
real U0_i, UA_i, UC_i, UD_i, UCS_i, EU_i, UTL_i, UTE_i, UA1_i, UD1_i, UCSTE_i, EUB_i, ETAMOB_i;
real U02_i, UA2_i, UC2_i, UD2_i, UCS2_i, EU2_i, EUB2_i, ETAMOB2_i, UP2_i;
real AT_i, ATB_i, PRT_i, IIT_i, TGIDL_i, TGISL_i, IGT_i;
real PCLM_i, PCLMCV_i, DROUT_i, PDIBL1_i, PDIBL2_i, PVAG_i,  ALPHA0_i, ALPHA1_i, BETA0_i;
real AIGC_i, BIGC_i, CIGC_i, PIGCD_i, DIGC_i;
real AGISL_i, BGISL_i, EGISL_i, PGISL_i, AGIDL_i, BGIDL_i, EGIDL_i, PGIDL_i;
real AIGS_i, BIGS_i, CIGS_i, DIGS_i, AIGD_i, BIGD_i, CIGD_i, DIGD_i;
real VBGIDL_i, VBEGIDL_i, VBGISL_i, VBEGISL_i;
real POXEDGE_i, NTOX_i, LOVS_i, LOVD_i, CFS_i, CFD_i;
real VSAT_i, VSATB_i, VSAT1_i, VSATCV_i;
real KSATIV_i, KSUBIV_i, UP_i, KSATIVB_i;
real AIGBINV_i, BIGBINV_i, CIGBINV_i, EIGBINV_i, NIGBINV_i;
real AIGBACC_i, BIGBACC_i, CIGBACC_i, NIGBACC_i;
real K0SISAT_i, K0SISAT1_i;

real k1, k2, A0, xg1, xg2, PHISsat, delta, phi2sub;
real f, df;

real q2, phi2;
real qfronts, qfrontd, qbacks, qbackd;
real qtots, qtotd;
real qicores, qicored;

// Newton Method Variables
real q, q1, dq2T2, qsqrt, dqsqrt;
real dqcoth, dqcothqdqsqrt, qcoth;
real dlogsinhqsqdqsqrt;
real phi1,lnA0,phi1_0,k1_2,PHISsatback2,PHISsatback;
real keq_k2 ;
real qt, auxb1,aaux, coth1;
real csc1;
// Threshold Operating Point
real qth, qsq1, qsqrt1, qcoth1, Vthop;
real g, dg1, dg2;


// Output Variables
`OPM(ID,      "A",    "Drain Current")
`OPM(IFG,     "A",    "Front Gate Current")
`OPM(IS,      "A",    "Source Current")
`OPM(III,     "A",    "Impact Ionization Current")
`OPM(IGIDL,   "A",    "Gate Induced Drain Leakage Current")
`OPM(IGISL,   "A",    "Gate Induced Source Leakage Current")
`OPM(IDS,     "A",    "Channel Current")
`OPP(VDSSAT,  "V",    "Drain-Source Saturation Voltage")
`OPM(GM,      "A/V",  "Transconductance")
`OPM(GDS,     "A/V",  "Output Conductance")
`OPM(GMBS,    "A/V",  "Body Transconductance")
`OPD(ROUT,    "V/A",  "Output Resistance")
`OPP(VFGS,    "V",    "Front Gate-Source Voltage")
`OPP(VFGD,    "V",    "Front Gate-Drain Voltage")
`OPP(VDS,     "V",    "Drain-Source Voltage")
`OPP(VSBG,    "V",    "Source-Back Gate Voltage")
`OPP(VDBG,    "V",    "Drain-Back Gate Voltage")
`OPM(QFG,     "C",    "Front Gate Charge")
`OPM(QBG,     "C",    "Back Gate Charge")
`OPM(QD,      "C",    "Drain Charge")
`OPM(QS,      "C",    "Source Charge")
`OPM(CFGD,    "F",    "Total fg-d MOSFET Capacitance")
`OPM(CFGFG,   "F",    "Total fg-fg MOSFET Capacitance")
`OPM(CFGS,    "F",    "Total fg-s MOSFET Capacitance")
`OPM(CFGBG,   "F",    "Total fg-bg MOSFET Capacitance")
`OPM(CBGD,    "F",    "Total bg-d MOSFET Capacitance")
`OPM(CBGFG,   "F",    "Total bg-fg MOSFET Capacitance")
`OPM(CBGS,    "F",    "Total bg-s MOSFET Capacitance")
`OPM(CBGBG,   "F",    "Total bg-bg MOSFET Capacitance")
`OPM(CDD,     "F",    "Total d-d MOSFET Capacitance")
`OPM(CDFG,    "F",    "Total d-fg MOSFET Capacitance")
`OPM(CDS,     "F",    "Total d-s MOSFET Capacitance")
`OPM(CDBG,    "F",    "Total d-bg MOSFET Capacitance")
`OPM(CSBG,    "F",    "Total s-bg MOSFET Capacitance")
`OPM(CSFG,    "F",    "Total s-fg MOSFET Capacitance")
`OPM(QFGI,    "C",    "Intrinsic Front Gate Charge")
`OPM(QBGI,    "C",    "Intrinsic Back Gate Charge")
`OPM(QDI,     "C",    "Intrinsic Drain Charge")
`OPM(QSI,     "C",    "Intrinsic Source Charge")
`OPM(CFGDI,   "F",    "Intrinsic fg-d MOSFET Capacitance")
`OPM(CFGFGI,  "F",    "Intrinsic fg-fg MOSFET Capacitance")
`OPM(CFGSI,   "F",    "Intrinsic fg-s MOSFET Capacitance")
`OPM(CSFGI,   "F",    "Intrinsic s-fg MOSFET Capacitance")
`OPM(CFGBGI,  "F",    "Intrinsic fg-bg MOSFET Capacitance")
`OPM(CBGDI,   "F",    "Intrinsic bg-d MOSFET Capacitance")
`OPM(CBGFGI,  "F",    "Intrinsic bg-fg MOSFET Capacitance")
`OPM(CBGSI,   "F",    "Intrinsic bg-s MOSFET Capacitance")
`OPM(CSBGI,   "F",    "Intrinsic s-bg MOSFET Capacitance")
`OPM(CBGBGI,  "F",    "Intrinsic bg-bg MOSFET Capacitance")
`OPM(CDDI,    "F",    "Intrinsic d-d MOSFET Capacitance")
`OPM(CDFGI,   "F",    "Intrinsic d-fg MOSFET Capacitance")
`OPM(CDSI,    "F",    "Intrinsic d-s MOSFET Capacitance")
`OPM(CDBGI,   "F",    "Intrinsic d-bg MOSFET Capacitance")
`OPM(PDISS,       "A*V",                "Device Power")
`OPP(VTH,         "V",                  "Threshold Voltage")
`OPP(T_TOTAL_K,   "Kelvin",             "Device temperature in Kelvin" )
`OPP(T_TOTAL_C,   "Celsius",            "Device temperature in Celsius" )
`OPP(T_DELTA_SH,  "Kelvin or Celsius",  "Delta temperature by self-heating" )

analog begin

    // ***************************************
    // **  Geometry-Dependent Calculations  **
    // ***************************************

    // Variable Initialization
    Rdrain  = 0.0;
    Rsource = 0.0;
    RSC0    = 0.0;
    RDC0    = 0.0;
    RSC0_t  = 0.0;
    RDC0_t  = 0.0;
    gspr    = 0.0;
    gdpr    = 0.0;
    Dr0     = 0.0;
    Grgeltd = 0.0;

    if ($port_connected(t) == 1) begin
        if (SHMOD == 0 || RTH0 == 0.0) begin
            $strobe("The optional 5th terminal is present but not active because SHMOD = 0 or RTH0 = 0.0");
        end
    end

    if (TYPE == `ntype) begin
        devsign = 1;
    end else begin
        devsign = -1;
    end

    if (WELLTYPE == `ntype) begin
        welsign = 1;
    end else begin
        welsign = -1;
    end

    // Constants
    epssi = EPSRSUB * `EPS0;

    // W calculation for different NFMOD options
    if (NFMOD == 0) begin
        Wnew = W / NF;
    end else begin
        Wnew = W;
    end

    //Leff and Weff for IV and CV
    Lnew        = L + XL;
    Wnew        = Wnew + XW;
    L_LLN       = pow(Lnew, -LLN);
    W_LWN       = pow(Wnew, -LWN);
    LW_LLN_LWN  = L_LLN * W_LWN;
    dLIV        = LINT + LL * L_LLN + LW * W_LWN + LWL * LW_LLN_LWN;
    L_WLN       = pow(Lnew, -WLN);
    W_WWN       = pow(Wnew, -WWN);
    LW_WLN_WWN  = L_WLN * W_WWN;
    dWIV        = WINT + WL * L_WLN + WW * W_WWN + WWL * LW_WLN_WWN;

    Leff = Lnew - 2.0 * dLIV;
    if (Leff <= 0.0) begin
        $error("Fatal: Effective channel length = %e for %M is non-positive", Leff);
    end else if (Leff <= 1.0e-9) begin
        $strobe("Warning: Effective channel length = %e for %M is <= 1.0e-9. Recommended Leff >= 1e-8", Leff);
    end

    Weff = Wnew - 2.0 * dWIV;
    if (Weff <= 0) begin
        $error("Fatal: Effective channel Width = %e for %M is non-positive", Weff);
    end else if (Weff<=1.0e-9) begin
        $strobe("Warning: Effective channel width = %e for %M is <= 1.0e-9. Recommended Weff >= 1e-8", Leff);
    end

    // Leff and Weff for CV
    dLCV   = DLC + LLC * L_LLN + LWC * W_LWN + LWLC * LW_LLN_LWN;
    dWCV   = DWC + WLC * L_WLN + WWC * W_WWN + WWLC * LW_WLN_WWN;
    LeffCV = Lnew - 2.0 * dLCV;

    if (LeffCV <= 0.0) begin
        $error("Fatal: Effective channel length for CV = %e for %M is non-positive", LeffCV);
    end else if (LeffCV <= 1.0e-9) begin
        $strobe("Warning: Effective channel length for CV = %e for %M is <= 1.0e-9. Recommended Leff >= 1e-8", LeffCV);
    end

    WeffCV = Wnew - 2.0 * dWCV;
    if (WeffCV <= 0.0) begin
        $error("Fatal: Effective channel width for CV = %e for %M is non-positive", WeffCV);
    end else if (WeffCV <= 1.0e-9) begin
        $strobe("Warning: Effective channel width for CV = %e for %M is <= 1.0e-9. Recommended Weff >= 1e-8", WeffCV);
    end

    // Binning
    Inv_L  = 1.0e-6 / Leff;
    Inv_W  = 1.0e-6 / Weff;
    Inv_WL = Inv_L * Inv_W;

    // Binning Calculations
    RDSW_i     = RDSW + LRDSW * Inv_L + WRDSW * Inv_W + PRDSW * Inv_WL;
    RDW_i      = RDW + LRDW * Inv_L + WRDW * Inv_W + PRDW * Inv_WL;
    RSW_i      = RSW + LRSW * Inv_L + WRSW * Inv_W + PRSW * Inv_WL;
    PRWG_i     = PRWG + LPRWG * Inv_L + WPRWG * Inv_W + PPRWG * Inv_WL;
    PRWB_i     = PRWB + LPRWB * Inv_L + WPRWB * Inv_W + PPRWB * Inv_WL;
    WR_i       = WR + LWR * Inv_L + WWR * Inv_W + PWR * Inv_WL;
    PHIG1_i    = PHIG1 + LPHIG1 * Inv_L + WPHIG1 * Inv_W + PPHIG1 * Inv_WL;
    PHIG2_i    = PHIG2 + LPHIG2 * Inv_L + WPHIG2 * Inv_W + PPHIG2 * Inv_WL;
    NSD_i      = NSD + LNSD * Inv_L + WNSD * Inv_W + PNSD * Inv_WL;
    NBODY_i    = NBODY + LNBODY * Inv_L + WNBODY * Inv_W + PNBODY * Inv_WL;
    CIT_i      = CIT + LCIT * Inv_L + WCIT * Inv_W + PCIT * Inv_WL;
    CDSC_i     = CDSC + LCDSC * Inv_L + WCDSC * Inv_W + PCDSC * Inv_WL;
    CDSCD_i    = CDSCD + LCDSCD * Inv_L + WCDSCD * Inv_W + PCDSCD * Inv_WL;
    CBGCBG_i   = CBGCBG + LCBGCBG * Inv_L + WCBGCBG * Inv_W + PCBGCBG * Inv_WL;
    BPFACTORPW_i = BPFACTORPW + LBPFACTORPW * Inv_L + WBPFACTORPW * Inv_W + PBPFACTORPW * Inv_WL;
    NOIA2_i    = NOIA2 + LNOIA2 * Inv_L + WNOIA2 * Inv_W + PNOIA2 * Inv_WL;
    QSREF_i    = QSREF + LQSREF * Inv_L + WQSREF * Inv_W + PQSREF * Inv_WL;
    MPOWER_i   = MPOWER + LMPOWER * Inv_L + WMPOWER * Inv_W + PMPOWER * Inv_WL;

    if (QSREF_i < 1.0e-12) begin
        $strobe("Warning: QSREF_i = %e is less than 1.0e-12, setting it to 1.0e-12", QSREF_i);
        QSREF_i = 1.0e-12;
    end

    if (BPFACTORPW_i < 0.0) begin
        $strobe("Warning: BPFACTORPW_i = %e is negative. Set to 0.0.", BPFACTORPW_i);
        BPFACTORPW_i = 0.0;
    end else if (BPFACTORPW_i > 1.0) begin
        $strobe("Warning: BPFACTORPW_i = %e is larger than 1.0. Set to 1.0.", BPFACTORPW_i);
        BPFACTORPW_i = 1.0;
    end

    VKNEE1PW_i   = VKNEE1PW + LVKNEE1PW * Inv_L + WVKNEE1PW * Inv_W + PVKNEE1PW * Inv_WL;
    VKNEE2PW_i   = VKNEE2PW + LVKNEE2PW * Inv_L + WVKNEE2PW * Inv_W + PVKNEE2PW * Inv_WL;
    DBGPW_i      = DBGPW + LDBGPW * Inv_L + WDBGPW * Inv_W + PDBGPW * Inv_WL;
    KBG0PW_i     = KBG0PW + LKBG0PW * Inv_L + WKBG0PW * Inv_W + PKBG0PW * Inv_WL;
    KBG1PW_i     = KBG1PW + LKBG1PW * Inv_L + WKBG1PW * Inv_W + PKBG1PW * Inv_WL;
    KBG2PW_i     = KBG2PW + LKBG2PW * Inv_L + WKBG2PW * Inv_W + PKBG2PW * Inv_WL;
    BPFACTORNW_i = BPFACTORNW + LBPFACTORNW * Inv_L + WBPFACTORNW * Inv_W + PBPFACTORNW * Inv_WL;

    if (BPFACTORNW_i < 0.0) begin
        $strobe("Warning: BPFACTORNW_i = %e is negative. Set to 0.0.", BPFACTORNW_i);
        BPFACTORNW_i = 0.0;
    end else if (BPFACTORNW_i > 1.0) begin
        $strobe("Warning: BPFACTORNW_i = %e is larger than 1.0. Set to 1.0.", BPFACTORNW_i);
        BPFACTORNW_i = 1.0;
    end

    VKNEE1NW_i = VKNEE1NW + LVKNEE1NW * Inv_L + WVKNEE1NW * Inv_W + PVKNEE1NW * Inv_WL;
    VKNEE2NW_i = VKNEE2NW + LVKNEE2NW * Inv_L + WVKNEE2NW * Inv_W + PVKNEE2NW * Inv_WL;
    DBGNW_i    = DBGNW + LDBGNW * Inv_L + WDBGNW * Inv_W + PDBGNW * Inv_WL;
    KBG0NW_i   = KBG0NW + LKBG0NW * Inv_L + WKBG0NW * Inv_W + PKBG0NW * Inv_WL;
    KBG1NW_i   = KBG1NW + LKBG1NW * Inv_L + WKBG1NW * Inv_W + PKBG1NW * Inv_WL;
    KBG2NW_i   = KBG2NW + LKBG2NW * Inv_L + WKBG2NW * Inv_W + PKBG2NW * Inv_WL;
    DVT0_i     = DVT0 + LDVT0 * Inv_L + WDVT0 * Inv_W + PDVT0 * Inv_WL;
    DVT1_i     = DVT1 + LDVT1 * Inv_L + WDVT1 * Inv_W + PDVT1 * Inv_WL;
    PHIN_i     = PHIN + LPHIN * Inv_L + WPHIN * Inv_W + PPHIN * Inv_WL;
    ETA0_i     = ETA0 + LETA0 * Inv_L + WETA0 * Inv_W + PETA0 * Inv_WL;
    ETA1_i     = ETA1 + LETA1 * Inv_L + WETA1 * Inv_W + PETA1 * Inv_WL;
    ETAB_i     = ETAB + LETAB * Inv_L + WETAB * Inv_W + PETAB * Inv_WL;
    DSUB_i     = DSUB + LDSUB * Inv_L + WDSUB * Inv_W + PDSUB * Inv_WL;
    DSC0_i     = DSC0 + LDSC0 * Inv_L + WDSC0* Inv_W + PDSC0 * Inv_WL;
    DSC1_i     = DSC1 + LDSC1 * Inv_L + WDSC1* Inv_W + PDSC1 * Inv_WL;
    ASCL_i     = ASCL + LASCL * Inv_L + WASCL * Inv_W + PASCL * Inv_WL;
    BSCL_i     = BSCL + LBSCL * Inv_L + WBSCL * Inv_W + PBSCL * Inv_WL;
    K1RSCE_i   = K1RSCE + LK1RSCE * Inv_L + WK1RSCE * Inv_W + PK1RSCE * Inv_WL;
    LPE0_i     = LPE0 + LLPE0 * Inv_L + WLPE0 * Inv_W + PLPE0 * Inv_WL;
    MEXP_i     = MEXP + LMEXP * Inv_L + WMEXP * Inv_W + PMEXP * Inv_WL;
    K0_i       = K0 + LK0 * Inv_L + WK0 * Inv_W + PK0 * Inv_WL;
    K01_i      = K01 + LK01 * Inv_L + WK01 * Inv_W + PK01 * Inv_WL;
    K0SI_i     = K0SI + LK0SI * Inv_L + WK0SI * Inv_W + PK0SI * Inv_WL;
    K0SI1_i    = K0SI1 + LK0SI1 * Inv_L + WK0SI1 * Inv_W + PK0SI1 * Inv_WL;
    K0SISAT_i  = K0SISAT + LK0SISAT * Inv_L + NK0SISAT * Inv_W + PK0SISAT * Inv_WL;
    K0SISAT1_i = K0SISAT1 + LK0SISAT1 * Inv_L + NK0SISAT1 * Inv_W + PK0SISAT1 * Inv_WL;
    PTWG_i     = PTWG + LPTWG * Inv_L + WPTWG * Inv_W + PPTWG * Inv_WL;
    PTWGB_i    = PTWGB + LPTWGB * Inv_L + WPTWGB * Inv_W + PPTWGB * Inv_WL;
    PTWGB2_i   = PTWGB2 + LPTWGB2 * Inv_L + WPTWGB2 * Inv_W + PPTWGB2 * Inv_WL;
    PTWGT_i    = PTWGT + LPTWGT * Inv_L + WPTWGT * Inv_W + PPTWGT * Inv_WL;
    U0_i       = U0 + LU0 * Inv_L + WU0 * Inv_W + PU0 * Inv_WL;
    UA_i       = UA + LUA * Inv_L + WUA * Inv_W + PUA * Inv_WL;
    UC_i       = UC + LUC * Inv_L + WUC * Inv_W + PUC * Inv_WL;
    UD_i       = UD + LUD * Inv_L + WUD * Inv_W + PUD * Inv_WL;
    UCS_i      = UCS + LUCS * Inv_L + WUCS * Inv_W + PUCS * Inv_WL;
    EU_i       = EU + LEU * Inv_L + WEU * Inv_W + PEU * Inv_WL;
    EUB_i      = EUB + LEUB * Inv_L + WEUB * Inv_W + PEUB * Inv_WL;
    UTL_i      = UTL + LUTL * Inv_L + WUTL * Inv_W + PUTL * Inv_WL;
    UTE_i      = UTE + LUTE * Inv_L + WUTE * Inv_W + PUTE * Inv_WL;
    UA1_i      = UA1 + LUA1 * Inv_L + WUA1 * Inv_W + PUA1 * Inv_WL;
    UD1_i      = UD1 + LUD1 * Inv_L + WUD1 * Inv_W + PUD1 * Inv_WL;
    UCSTE_i    = UCSTE + LUCSTE * Inv_L + WUCSTE * Inv_W + PUCSTE * Inv_WL;
    ETAMOB_i   = ETAMOB + LETAMOB * Inv_L + WETAMOB * Inv_W + PETAMOB * Inv_WL;
    U02_i      = U02 + LU02 * Inv_L + WU02 * Inv_W + PU02 * Inv_WL;
    UA2_i      = UA2 + LUA2 * Inv_L + WUA2 * Inv_W + PUA2 * Inv_WL;
    UC2_i      = UC2 + LUC2 * Inv_L + WUC2 * Inv_W + PUC2 * Inv_WL;
    UD2_i      = UD2 + LUD2 * Inv_L + WUD2 * Inv_W + PUD2 * Inv_WL;
    UCS2_i     = UCS2 + LUCS2 * Inv_L + WUCS2 * Inv_W + PUCS2 * Inv_WL;
    EU2_i      = EU2 + LEU2 * Inv_L + WEU2 * Inv_W + PEU2 * Inv_WL;
    EUB2_i     = EUB2 + LEUB2 * Inv_L + WEUB2 * Inv_W + PEUB2 * Inv_WL;
    ETAMOB2_i  = ETAMOB2 + LETAMOB2 * Inv_L + WETAMOB2 * Inv_W + PETAMOB2 * Inv_WL;
    AT_i       = AT + LAT * Inv_L + WAT * Inv_W + PAT * Inv_WL;
    ATB_i      = ATB + LATB * Inv_L + WATB * Inv_W + PATB * Inv_WL;
    PRT_i      = PRT + LPRT * Inv_L + WPRT * Inv_W + PPRT * Inv_WL;
    IIT_i      = IIT + LIIT * Inv_L + WIIT * Inv_W + PIIT * Inv_WL;
    TGIDL_i    = TGIDL + LTGIDL * Inv_L + WTGIDL * Inv_W + PTGIDL * Inv_WL;
    TGISL_i    = TGISL + LTGISL * Inv_L + WTGISL * Inv_W + PTGISL * Inv_WL;
    IGT_i      = IGT + LIGT * Inv_L + WIGT * Inv_W + PIGT * Inv_WL;
    PCLM_i     = PCLM + LPCLM * Inv_L + WPCLM * Inv_W + PPCLM * Inv_WL;
    PCLMCV_i   = PCLMCV + LPCLMCV * Inv_L + WPCLMCV * Inv_W + PPCLMCV * Inv_WL;
    DROUT_i    = DROUT + LDROUT * Inv_L + WDROUT * Inv_W + PDROUT * Inv_WL;
    PDIBL1_i   = PDIBL1 + LPDIBL1 * Inv_L + WPDIBL1 * Inv_W + PPDIBL1 * Inv_WL;
    PDIBL2_i   = PDIBL2 + LPDIBL2 * Inv_L + WPDIBL2 * Inv_W + PPDIBL2 * Inv_WL;
    PVAG_i     = PVAG + LPVAG * Inv_L + WPVAG * Inv_W + PPVAG * Inv_WL;
    ALPHA0_i   = ALPHA0 + LALPHA0 * Inv_L + WALPHA0 * Inv_W + PALPHA0 * Inv_WL;
    ALPHA1_i   = ALPHA1 + LALPHA1 * Inv_L + WALPHA1 * Inv_W + PALPHA1 * Inv_WL;
    BETA0_i    = BETA0 + LBETA0 * Inv_L + WBETA0 * Inv_W + PBETA0 * Inv_WL;
    AIGBINV_i  = AIGBINV + Inv_L * LAIGBINV + Inv_W * WAIGBINV + Inv_WL * PAIGBINV;
    BIGBINV_i  = BIGBINV + Inv_L * LBIGBINV + Inv_W * WBIGBINV + Inv_WL * PBIGBINV;
    CIGBINV_i  = CIGBINV + Inv_L * LCIGBINV + Inv_W * WCIGBINV + Inv_WL * PCIGBINV;
    EIGBINV_i  = EIGBINV + Inv_L * LEIGBINV + Inv_W * WEIGBINV + Inv_WL * PEIGBINV;
    NIGBINV_i  = NIGBINV + Inv_L * LNIGBINV + Inv_W * WNIGBINV + Inv_WL * PNIGBINV;
    AIGBACC_i  = AIGBACC + Inv_L * LAIGBACC + Inv_W * WAIGBACC + Inv_WL * PAIGBACC;
    BIGBACC_i  = BIGBACC + Inv_L * LBIGBACC + Inv_W * WBIGBACC + Inv_WL * PBIGBACC;
    CIGBACC_i  = CIGBACC + Inv_L * LCIGBACC + Inv_W * WCIGBACC + Inv_WL * PCIGBACC;
    NIGBACC_i  = NIGBACC + Inv_L * LNIGBACC + Inv_W * WNIGBACC + Inv_WL * PNIGBACC;
    AIGC_i     = AIGC + LAIGC * Inv_L + WAIGC * Inv_W + PAIGC * Inv_WL;
    BIGC_i     = BIGC + LBIGC * Inv_L + WBIGC * Inv_W + PBIGC * Inv_WL;
    CIGC_i     = CIGC + LCIGC * Inv_L + WCIGC * Inv_W + PCIGC * Inv_WL;
    DIGC_i     = DIGC + LDIGC * Inv_L + WDIGC * Inv_W + PDIGC * Inv_WL;
    PIGCD_i    = PIGCD + LPIGCD * Inv_L + WPIGCD * Inv_W + PPIGCD * Inv_WL;
    PGIDL_i    = PGIDL + LPGIDL * Inv_L + WPGIDL * Inv_W + PPGIDL * Inv_WL;
    AGISL_i    = AGISL + LAGISL * Inv_L + WAGISL * Inv_W + PAGISL * Inv_WL;
    BGISL_i    = BGISL + LBGISL * Inv_L + WBGISL * Inv_W + PBGISL * Inv_WL;
    EGISL_i    = EGISL + LEGISL * Inv_L + WEGISL * Inv_W + PEGISL * Inv_WL;
    PGISL_i    = PGISL + LPGISL * Inv_L + WPGISL * Inv_W + PPGISL * Inv_WL;
    AGIDL_i    = AGIDL + LAGIDL * Inv_L + WAGIDL * Inv_W + PAGIDL * Inv_WL;
    BGIDL_i    = BGIDL + LBGIDL * Inv_L + WBGIDL * Inv_W + PBGIDL * Inv_WL;
    EGIDL_i    = EGIDL + LEGIDL * Inv_L + WEGIDL * Inv_W + PEGIDL * Inv_WL;
    VBGIDL_i   = VBGIDL + LVBGIDL * Inv_L + WVBGIDL * Inv_W + PVBGIDL * Inv_WL;
    VBGISL_i   = VBGISL + LVBGISL * Inv_L + WVBGISL * Inv_W + PVBGISL * Inv_WL;
    VBEGIDL_i  = VBEGIDL + LVBEGIDL * Inv_L + WVBEGIDL * Inv_W + PVBEGIDL * Inv_WL;
    VBEGISL_i  = VBEGISL + LVBEGISL * Inv_L + WVBEGISL * Inv_W + PVBEGISL * Inv_WL;
    AIGS_i     = AIGS + LAIGS * Inv_L + WAIGS * Inv_W + PAIGS * Inv_WL;
    BIGS_i     = BIGS + LBIGS * Inv_L + WBIGS * Inv_W + PBIGS * Inv_WL;
    CIGS_i     = CIGS + LCIGS * Inv_L + WCIGS * Inv_W + PCIGS * Inv_WL;
    DIGS_i     = DIGS + LDIGS * Inv_L + WDIGS * Inv_W + PDIGS * Inv_WL;
    AIGD_i     = AIGD + LAIGD * Inv_L + WAIGD * Inv_W + PAIGD * Inv_WL;
    BIGD_i     = BIGD + LBIGD * Inv_L + WBIGD * Inv_W + PBIGD * Inv_WL;
    CIGD_i     = CIGD + LCIGD * Inv_L + WCIGD * Inv_W + PCIGD * Inv_WL;
    DIGD_i     = DIGD + LDIGD * Inv_L + WDIGD * Inv_W + PDIGD * Inv_WL;
    NTOX_i     = NTOX + LNTOX * Inv_L + WNTOX * Inv_W + PNTOX * Inv_WL;
    POXEDGE_i  = POXEDGE + LPOXEDGE * Inv_L + WPOXEDGE * Inv_W + PPOXEDGE * Inv_WL;
    LOVS_i     = LOVS + LLOVS * Inv_L + WLOVS * Inv_W + PLOVS * Inv_WL;
    LOVD_i     = LOVD + LLOVD * Inv_L + WLOVD * Inv_W + PLOVD * Inv_WL;
    CFS_i      = CFS + LCFS * Inv_L + WCFS * Inv_W + PCFS * Inv_WL;
    CFD_i      = CFD + LCFD * Inv_L + WCFD * Inv_W + PCFD * Inv_WL;
    VSAT_i     = VSAT + LVSAT * Inv_L + WVSAT * Inv_W + PVSAT * Inv_WL;
    VSATB_i    = VSATB + LVSATB * Inv_L + WVSATB * Inv_W + PVSATB * Inv_WL;
    VSAT1_i    = VSAT1 + LVSAT1 * Inv_L + WVSAT1 * Inv_W + PVSAT1 * Inv_WL;
    VSATCV_i   = VSATCV + LVSATCV * Inv_L + WVSATCV * Inv_W + PVSATCV * Inv_WL;
    KSATIV_i   = KSATIV + LKSATIV * Inv_L + WKSATIV * Inv_W + PKSATIV * Inv_WL;
    KSUBIV_i   = KSUBIV + LKSUBIV * Inv_L + WKSUBIV * Inv_W + PKSUBIV * Inv_WL;
    KSATIVB_i  = KSATIVB + LKSATIVB * Inv_L + WKSATIVB * Inv_W + PKSATIVB * Inv_WL;
    UP_i       = UP + LUP * Inv_L + WUP * Inv_W + PUP * Inv_WL;
    UP2_i      = UP2 + LUP2 * Inv_L + WUP2 * Inv_W + PUP2 * Inv_WL;
    QMTCENCV_i = QMTCENCV + LQMTCENCV * Inv_L + WQMTCENCV * Inv_W + PQMTCENCV * Inv_WL;
    ETAQM_i    = ETAQM + LETAQM * Inv_L + WETAQM * Inv_W + PETAQM * Inv_WL;
    QM0_i      = QM0 + LQM0 * Inv_L + WQM0 * Inv_W + PQM0 * Inv_WL;
    PQM_i      = PQM + LPQM * Inv_L + WPQM * Inv_W + PPQM * Inv_WL;

    if (NQSMOD == 1 && XRCRG1 != 0.0) begin
        XRCRG1_i = XRCRG1 + LXRCRG1 * Inv_L + WXRCRG1 * Inv_W + PXRCRG1 * Inv_WL;
        XRCRG2_i = XRCRG2 + LXRCRG2 * Inv_L + WXRCRG2 * Inv_W + PXRCRG2 * Inv_WL;
    end else begin
        XRCRG1_i = 0.0;
        XRCRG2_i = 0.0;
    end

    cox1     = 3.9 * `EPS0 / EOT1;
    cox1P    = 3.9 * `EPS0 / EOT1P;
    cox2     = 3.9 * `EPS0 / EOT2;
    csi      = epssi / TSI;
    epsratio = EPSRSUB / 3.9;

    // Physical Oxide Thickness
    if (!$param_given(EOT1P)) begin
        IMGTOXP = (EOT1 * EPSROX1 / 3.9) - DTOX1;
    end else begin
        IMGTOXP = EOT1P;
    end

    // Geometrical Scaling
    if (LPA > 0.0) begin
        U0_i = U0_i * (1.0 - UP_i * pow(Leff, -LPA));
    end else begin
        U0_i = U0_i * (1.0 - UP_i);
    end

    UA_i     = UA_i + AUA * lexp(-Leff / BUA);
    UC_i     = UC_i + AUC * lexp(-Leff / BUC);
    UDB_i    = UDB + AUDB * lexp(-Leff / BUDB);
    UD_i     = UD_i + AUD * lexp(-Leff / BUD);
    EU_i     = EU_i + AEU * lexp(-Leff / BEU);
    EUB_i    = EUB_i + AEUB * lexp(-Leff / BEUB);

    if (LPA2 > 0.0) begin
        U02_i = U02_i * (1.0 - UP2_i * pow(Leff, -LPA2));
    end else begin
        U02_i = U02_i * (1.0 - UP2_i);
    end

    UA2_i    = UA2_i + AUA2 * lexp(-Leff / BUA2);
    UC2_i    = UC2_i + AUC2 * lexp(-Leff / BUC2);
    UDB2_i   = UDB2 + AUDB2 * lexp(-Leff / BUDB2);
    UD2_i    = UD2_i + AUD2 * lexp(-Leff / BUD2);
    EU2_i    = EU2_i + AEU2 * lexp(-Leff / BEU2);
    EUB2_i   = EUB2_i + AEUB2 * lexp(-Leff / BEUB2);

    if (RDSMOD == 1) begin
        RSW_i = RSW_i + ARSW * lexp(-Leff / BRSW);
        RDW_i = RDW_i + ARDW * lexp(-Leff / BRDW);
    end else begin
        RDSW_i = RDSW_i + ARDSW * lexp(-Leff / BRDSW);
    end

    PCLM_i   = PCLM_i + APCLM * lexp(-Leff / BPCLM);
    MEXP_i   = MEXP_i + AMEXP * pow(Leff * 1.0e6, -BMEXP);
    PTWG_i   = PTWG_i + APTWG * lexp(-Leff / BPTWG);
    PTWGB_i  = PTWGB_i + APTWGB * lexp(-Leff / BPTWGB);
    PTWGB2_i = PTWGB2_i + APTWGB2 * lexp(-Leff / BPTWGB2);
    VSAT_i   = VSAT_i + AVSAT * lexp(-Leff / BVSAT);
    VSATB_i  = VSATB_i + AVSATB * lexp(-Leff / BVSATB);
    VSAT1_i  = VSAT1_i + AVSAT1 * lexp(-Leff / BVSAT1);
    VSATCV_i = VSATCV_i + AVSATCV * lexp(-Leff / BVSATCV);

    // Scaling for DITS Parameters
    DVTP0_i = DVTP0 + ADVTP0 * lexp(-Leff / BDVTP0);
    DVTP1_i = DVTP1 + ADVTP1 * lexp(-Leff / BDVTP1);

    // Aging Effects
    if (DELHCI != 0.0) begin
        exp_hci = lexp(-HCIDB1 * devsign * (V(d, s) - V(bg, s)) + HCIDB0);
        UD_i     = UD_i + DELHCI * (HCIUD + HCIDUD * exp_hci);
        U0_i     = U0_i + DELHCI * (HCIU0 + HCIDU0 * exp_hci);
        VSAT_i   = VSAT_i + DELHCI * (HCIVSAT + HCIDVSAT * exp_hci);
        CIT_i    = CIT_i + DELHCI * (HCICIT + HCIDCIT * exp_hci);
        UCS_i    = UCS_i + DELHCI * (HCIUCS + HCIDUCS * exp_hci);
        dvth_hci = DELHCI * (HCIVTH + HCIDVTH * exp_hci);
    end else begin
        dvth_hci = 0.0;
    end

    // **************************
    // **  Parameter Checking  **
    // **************************

    begin: ParameterCheck
        if (U0_i < 0.0) begin
            U0_i = 0.03;
        end

        if (UA_i < 0.0) begin
            $strobe("Warning: UA_i = %e is negative, setting it to 0.", UA_i);
            UA_i = 0.0;
        end

        if (EU_i < 0.0) begin
            $strobe("Warning: EU_i = %e is negative, setting it to 0.", EU_i);
            EU_i = 0.0;
        end

        if (UD_i < 0.0) begin
            UD_i = 0.0;
        end

        if (UCS_i < 0.0) begin
            UCS_i = 0.0;
        end

        if (VSATB_i < 0.0) begin
            $strobe("Warning: VSATB_i = %e is negative, setting it to 0.", VSATB_i);
            VSATB_i = 0.0;
        end

        if (DVT1_i <= 0.0) begin
            $error("Fatal: DVT1_i = %e is not positive.", DVT1_i);
        end

        if (DSUB_i <= 0.0) begin
            $error("Fatal: DSUB_i = %e is not positive.", DSUB_i);
        end

        RDSWMIN_i = RDSWMIN;

        if (RDSW_i < 0.0) begin
            $strobe("Warning: RDSW_i = %e is negative, setting it to 0.", RDSW_i);
            RDSW_i = 0.0;
        end

        RSWMIN_i = RSWMIN;

        if (RSW_i < 0.0) begin
            $strobe("Warning: RSW_i = %e is negative, setting it to 0.", RSW_i);
            RSW_i = 0.0;
        end

        RDWMIN_i = RDWMIN;

        if (RDW_i < 0.0) begin
            $strobe("Warning: RDW_i = %e is negative, setting it to 0.", RDW_i);
            RDW_i = 0.0;
        end

        if (PRWG_i < 0.0) begin
            $strobe("Warning: PRWG_i = %e is negative, setting it to 0.", PRWG_i);
            PRWG_i = 0.0;
        end

        if (PDIBL1_i < 0.0) begin
            $strobe("Warning: PDIBL1_i = %e is negative.", PDIBL1_i);
        end

        if (PDIBL2_i < 0.0) begin
            $strobe("Warning: PDIBL2_i = %e is negative.", PDIBL2_i);
        end

        if (DROUT_i <= 0.0) begin
            $strobe("Warning: DROUT_i = %e is not positive.", DROUT_i);
        end

        if (MEXP_i < 2.0) begin
            $strobe("Warning: MEXP_i = %e < 2. Set MEXP_i to 2.", MEXP_i);
            MEXP_i = 2.0;
        end

    end

    // Short Channel Effects
    Theta_RSCE = sqrt(1.0 + LPE0_i / Leff) - 1.0;
    teff       = TSI + epsratio * (EOT1 + EOT2);

    // Variable to be used in Drain Saturation Voltage
    inv_MEXP = 1.0 / MEXP_i;

    // Source/drain to substrate parasitic capacitances
    csbox = cox2 * AS;
    cdbox = cox2 * AD;
    T0    = CSDBGSW * lln(1.0 + TSI / EOT2);
    csbox = csbox + T0 * max(PS - W, 0.0);
    cdbox = cdbox + T0 * max(PD - W, 0.0);

    // For better convergence
    csbox = max(csbox, 0.01e-18);
    cdbox = max(cdbox, 0.01e-18);

    // Mobility Degradation
    if (TYPE == `ntype) begin
        eta_mu    = 0.5 * ETAMOB_i;
        eta_mu_cv = 0.5;
        eta_mu2   = 0.5 * ETAMOB2_i;
    end else begin
        eta_mu    = 1.0 / 3.0 * ETAMOB_i;
        eta_mu_cv = 1.0 / 3.0;
        eta_mu2   = 1.0 / 3.0 * ETAMOB2_i;
    end

    EeffFactor   = 1.0e-8 / (epsratio * EOT1);
    WeffWRFactor = 1.0 / (pow((Weff) * 1.0e6, WR_i) * NF);
    litl         = sqrt(epsratio * EOT1 * TSI);
    EeffFactor2  = 1.0e-8 / (epsratio * EOT2);

    if (LINTNOI >= Leff / 2.0) begin
        $strobe("Warning: LINTNOI = %e is too large - Leff for noise is negative. Re-setting LINTNOI = 0.", LINTNOI);
        LINTNOI_i = 0.0;
    end else begin
        LINTNOI_i = LINTNOI;
    end

    // Self-heating Model
    if ((SHMOD != 0) && (RTH0 > 0.0)) begin
        gth = (WTH0 + Weff) * NF / RTH0;
        cth = CTH0 * (WTH0 + Weff) * NF;
    end else begin
        // set gth to some value to prevent a singular G matrix
        gth = 1.0;
        cth = 0.0;
    end

    // Geometry dependent Source/Drain Resistance
    RSourceGeo = RSHS * NRS;
    RDrainGeo  = RSHD * NRD;

    // Clamping of Source/Drain Resistances
    if (RDSMOD == 0) begin
        if (RSourceGeo < minr) begin
            RSourceGeo = 0;
        end
        if (RDrainGeo < minr) begin
            RDrainGeo = 0;
        end
    end else begin
        if (RSourceGeo <= minr) begin
            RSourceGeo = minr;
        end
        if (RDrainGeo <= minr) begin
            RDrainGeo = minr;
        end
    end

    Tnom = TNOM + `P_CELSIUS0;

    // Gate Current
    if (TYPE == `ntype) begin
        Aechvb = 4.97232e-7;  // NMOS
    end else begin
        Aechvb = 3.42537e-7;  // PMOS
    end

    if (TYPE == `ntype) begin
        Bechvb = 7.45669e11;  // NMOS
    end else begin
        Bechvb = 1.16645e12;  // PMOS
    end

    T0 = TOXP * TOXP;
    T1 = TOXP * POXEDGE_i;
    T2 = T1 * T1;

    Toxratio     = lexp(NTOX_i * lln(TOXREF / TOXP)) / T0;
    Toxratioedge = lexp(NTOX_i * lln(TOXREF / T1)) / T2;
    igsd_mult0   = Weff * Aechvb * Toxratioedge;

    // Gate Resistance
    Grgeltd = RSHG * (XGW + Weff / 3.0 / NGCON) / (NGCON * NF * (Lnew - XGL));

    if (Grgeltd > 0.001) begin
        Grgeltd = 1.0 / Grgeltd;
    end else begin
        Grgeltd = 1.0e3;
        if (RGATEMOD != 0) begin
            $strobe("Warning: (instance %M) The gate conductance reset to 1.0e3 mho.");
        end
    end


    // ******************************************
    // **  Temperature-Dependent Calculations  **
    // ******************************************

    DevTemp0 = $temperature + DTEMP; // Self-Heating induced temperature not included for bias-indpendent resistances in RDSMOD=0

    if (SHMOD != 0 && RTH0 > 0.0) begin
        DevTemp = $temperature + Temp(rth_branch) + DTEMP;
    end else begin
        DevTemp = $temperature + DTEMP;
    end

    TMAXK  = TMAXC + `P_CELSIUS0; // TMAX in Kelvin

    DevTemp  = minx(DevTemp, TMAXK,  1.0e-2); //Limiting maximum temperature

    begin: IMGTempDepCalc

        TRatio  = DevTemp / Tnom;
        delTemp = DevTemp - Tnom;
        delTemp0 = DevTemp0 - Tnom;   // Self-Heating induced temperature not included for bias-indpendent resistances in RDSMOD=0

        // Temperature-Dependent Quantities
        Vtm    = `KboQ * DevTemp;
        Eg     = BG0SUB - TBGASUB * DevTemp * DevTemp / (DevTemp + TBGBSUB);
        T1     = (DevTemp / 300.15) * sqrt(DevTemp / 300.15);
        ni     = NI0SUB * T1 * lexp(BG0SUB / (2.0 * `KboQ * 300.15) - Eg / (2.0 * Vtm));
        vbi    = Vtm * lln(NSD_i * NBODY_i / (ni * ni));
        phib   = Vtm * lln(NBODY_i / ni);
        phisub = (0.5 * Eg - hypsmooth(0.5 * Eg - Vtm * lln(NBG / ni), 1.0e-4));

        // Front- and Back-Gate Workfunctions
        if ((NBG != 0.0) && (!$param_given(PHIG2))) begin
            if (WELLTYPE == `ptype) begin
                PHIG2_i = PHIG2_i - 0.5 * BG0SUB + phisub;
            end else begin
                PHIG2_i = PHIG2_i + 0.5 * BG0SUB - phisub;
            end
        end

        PhiRef    = EASUB + Eg / 2.0;
        deltaphi1 = devsign * (PHIG1_i - PhiRef);
        deltaphi2 = devsign * (PHIG2_i - PhiRef);

        PhiSD = EASUB + Eg / 2.0 - devsign * min(Eg / 2.0, Vtm * lln(NSD_i / ni));
        vfbsd = devsign * (PHIG1_i - PhiSD);  // for GIDL and Cov
        vfbsd_bg = devsign * (PHIG2_i - PhiSD);  // Flat-band voltage of back MOS for GIDL and COV Calculation

        // Temperature Effects
        U0_t  = U0_i * pow(TRatio, UTE_i) * (1.0 + hypsmooth(0.9 + UTL_i * delTemp, 1.0e-3) - hypsmooth(0.9, 1.0e-3));
        UC_t  = UC_i * hypsmooth(1.0 + UC1 * delTemp - 1.0e-6, 1.0e-3);
        UA_t  = UA_i * hypsmooth(1.0 + UA1_i * delTemp - 1.0e-6, 1.0e-3);
        UD_t  = UD_i * pow(TRatio, UD1_i);
        UCS_t = UCS_i * pow(TRatio, UCSTE_i);

        rdstemp = hypsmooth(1.0 + PRT_i * delTemp - 1.0e-6, 1.0e-3);
        AT_i    = AT_i * (1.0 + Inv_L * ATL);
        VSAT_t  = VSAT_i * (1.0 + hypsmooth(0.9 - AT_i * delTemp, 1.0e-3) - hypsmooth(0.9, 1.0e-3));

        if (RDSMOD == 0) begin
            //bias-independent resistances are Ambient Temperature dependent
            RSC0 = RSC * smoothminx(1.0 + TRS * delTemp0 - 1.0E-6, 1.0E-3, 0.01);
            RDC0 = RDC * smoothminx(1.0 + TRD * delTemp0 - 1.0E-6, 1.0E-3, 0.01);
            RSC0_t = RSC0;
            RDC0_t = RDC0;
        end else begin
            RSC0 = RSC * smoothminx(1.0 + TRS * delTemp0 - 1.0E-6, 1.0E-3, 0.01);
            RDC0 = RDC * smoothminx(1.0 + TRD * delTemp0 - 1.0E-6, 1.0E-3, 0.01);
            RSC0_t = RSC * smoothminx(1.0 + TRS * delTemp - 1.0E-6, 1.0E-3, 0.01);
            RDC0_t = RDC * smoothminx(1.0 + TRD * delTemp - 1.0E-6, 1.0E-3, 0.01);
        end

        if (RDSMOD == 0) begin
            if (RSC0 < minr) begin
                $strobe("Warning: RSC0 = %e is smaller than minr. Set to 0.",RSC0);
                RSC0 = 0;
                RSC0_t = 0;
            end
            if (RDC0 < minr) begin
                $strobe("Warning: RDC0 = %e is smaller than minr. Set to 0.",RDC0);
                RDC0 = 0;
                RDC0_t = 0;
            end
        end else begin
            if (RSC0 < minr) begin
                $strobe("Warning: RSC0 = %e is smaller than minr. Set to minr.",RSC0);
                RSC0 = minr;
            end
            if (RSC0_t < minr) begin
                RSC0_t = minr;
            end
            if (RDC0 < minr) begin
                $strobe("Warning: RDC0 = %e is smaller than minr. Set to minr.",RDC0);
                RDC0 = minr;
            end
            if (RDC0_t < minr) begin
                RDC0_t = minr;
            end
        end

        if (VSAT_t < 1000) begin
            VSAT_t = 1000;
        end

        VSAT1_t = VSAT1_i * (1.0 + hypsmooth(0.9 - AT_i * delTemp, 1.0e-3) - hypsmooth(0.9, 1.0e-3));
        if (VSAT1_t < 1000) begin
            VSAT1_t = 1000;
        end

        VSATCV_t = VSATCV_i * (1.0 + hypsmooth(0.9 - AT_i * delTemp, 1.0e-3) - hypsmooth(0.9, 1.0e-3));
        if (VSATCV_t < 1000) begin
            VSATCV_t = 1000;
        end

        ETA0_t     = ETA0_i * (1.0 + hypmax(TETA0 * delTemp, -0.9, 1e-4));
        ATB_i      = ATB_i *(1.0 +  Inv_L * ATBL);
        VSATB_t    = VSATB_i * (1.0 + hypsmooth(0.9 - ATB_i * delTemp, 1.0e-3) - hypsmooth(0.9, 1.0e-3));
        MEXP_t     = hypsmooth(MEXP_i * (1.0 + TMEXP * delTemp)-2.0 , 1.0e-3) + 2.0;
        K0_t       = K0_i + K01_i * delTemp;
        K0SI_t     = K0SI_i + hypmax(K0SI1_i  * delTemp, -K0SI_i, 1.0e-6);
        K0SISAT_t  = K0SISAT_i + K0SISAT1_i * delTemp;
        PTWG_t     = PTWG_i * hypsmooth(1.0 - PTWGT_i * delTemp - 1.0e-6, 1.0e-3);
        dvth_temp0 = (KT1 + KT1L / Leff) * (TRatio - 1.0);
        BETA0_t    = BETA0_i * pow(TRatio, IIT_i);
        BGIDL_t    = BGIDL_i * hypsmooth(1.0 + TGIDL_i * delTemp - 1.0e-6, 1.0e-3);
        BGISL_t    = BGISL_i * hypsmooth(1.0 + TGISL_i * delTemp - 1.0e-6, 1.0e-3);
        igtemp     = lexp(IGT_i * lln(TRatio));
        igsd_mult  = igsd_mult0 * igtemp;
    end

    // ***********************************
    // **  Bias-Dependent Calculations  **
    // ***********************************

    // Load Terminal Voltages
    vgs_noswap  = devsign * V(gi, si);
    vds_noswap  = devsign * V(di, si);
    vgd_noswap  = devsign * V(gi, di);
    vbgs_noswap = devsign * V(bg, si);
    vbgd_noswap = devsign * V(bg, di);
    vgbg        = devsign * V(gi, bg);

    // Source-Drain Change
    sigvds = 1.0;

    if (vds_noswap < 0.0) begin
        sigvds = -1.0;
        vfgs   = vgd_noswap;
        vds    = -vds_noswap;
        vbgs   = vbgd_noswap;
        vbgd   = vbgs_noswap;
    end else begin
        vfgs   = vgs_noswap;
        vds    = vds_noswap;
        vbgs   = vbgs_noswap;
        vbgd   = vbgd_noswap;
    end

    vgd_ov_noswap = devsign * V(ge, di);
    vgs_ov_noswap = devsign * V(ge, si);

    vdsx  = sqrt(vds * vds + 0.0004) - 0.02;
    symmetry_factor = 0.5 * (vdsx - vds);
    vbgx  = vbgs + symmetry_factor;
    vgfb1 = vfgs - deltaphi1;
    vgfb2 = vbgs - deltaphi2;

    // Back-gate Bias Dependence
    sclf = sqrt(epsratio * TSI * EOT1);
    sclm = sqrt(TSI * (epsratio * EOT1 + 0.375 * TSI));
    T0   = (vgfb1 * (EOT2 * epsratio) + vgfb2 * (EOT1 * epsratio + TSI)) / teff + symmetry_factor;
    T1   = atan(ASCL_i + BSCL_i * T0) / `M_PI + 0.5;
    scl  = sclm + T1 * (sclf - sclm);

    tmp = DVT1_i * Leff / scl + 1.0e-6;
    if (tmp < 40.0) begin
        Theta_SCE = 0.5 / (cosh(tmp) - 1.0);
    end else begin
        Theta_SCE = lexp(-tmp);
    end

    tmp = DSUB_i * Leff / scl + 1.0e-6;
    if (tmp < 40.0) begin
        Theta_DIBL = 0.5 / (cosh(tmp) - 1.0);
    end else begin
        Theta_DIBL = lexp(-tmp);
    end

    if (tmp < 40.0) begin
        Theta_DITS = 1.0 / max((1.0 + DVTP2 * (cosh(tmp) - 2.0)), 1.0e-6);
    end else begin
        Theta_DITS = lexp(-tmp) / max((lexp(-tmp) + DVTP2), 1.0e-6);
    end

    tmp = DROUT_i * Leff / scl + 1.0e-6;
    if (tmp < 40.0) begin
        DIBLfactor = 0.5 * PDIBL1_i / (cosh(tmp) - 1.0) +PDIBL2_i;
    end else begin
        DIBLfactor = PDIBL1_i * lexp(-tmp) + PDIBL2_i;
    end

    // Back-gate Bias Effect
    if (WELLTYPE == `ptype) begin
        temp = DBGPW_i * Leff / scl;
        if (temp > 40.0) begin
            T0 = lexp(temp)/2.0;
        end else begin
            T0 = cosh(temp) - 1.0;
        end
        T1       = KBG0PW_i - 0.5 * KBG1PW_i / T0;
        T2       = KBG2PW_i;
        vknee1   = VKNEE1PW_i;
        vknee2   = VKNEE2PW_i;
        bpfactor = BPFACTORPW_i;
    end else begin
        temp = DBGNW_i * Leff / scl;
        if (temp > 40.0) begin
            T0 = lexp(temp) / 2.0;
        end else begin
            T0 = cosh(temp) - 1.0;
        end
        T1       = KBG0NW_i - 0.5 * KBG1NW_i / T0;
        T2       = KBG2NW_i;
        vknee1   = VKNEE1NW_i;
        vknee2   = VKNEE2NW_i;
        bpfactor = BPFACTORNW_i;
    end

    T0   = T1 - T2;
    kvbg = T2 + 0.5 * (T0 + sqrt(T0 * T0 + 0.0001));

    // Back-gate Depletion Effect
    vsubdep0 = `q * NBG * epssi / (2.0 * cox2 * cox2);

    if (NBG != 0.0) begin
        T0 = sqrt(1.0 + hypsmooth(welsign * (devsign * vbgx - vknee1), 1.0e-2) / vsubdep0) - 1.0;
    end else begin
        T0 = 0.0;
    end

    vsubdep  = vsubdep0 * T0 * T0;
    vsubdep  = -hypmax(-vsubdep, -vknee2, 1.0e-2);
    vgfb2eff = -1.2 - symmetry_factor;
    gamma0   = -cox2 * csi / ((cox2 + csi) * cox1);
    dvth_vbg = gamma0 * kvbg * (vgfb2 - (devsign * welsign * bpfactor * vsubdep) - vgfb2eff);

    // SCE, DIBL, RSCE, and SS degradation effects, Ref: BSIM4
    vbgxpos     = hypsmooth(vbgx, 1.0e-3);
    phist       = 0.4 + phib + PHIN_i;
    if (phist <0) begin
        dvth_rsce = 0;
    end else begin
        dvth_rsce   = K1RSCE_i * Theta_RSCE * sqrt(phist);
    end
    dvth_vtroll = -DVT0_i * Theta_SCE * (vbi - phist);
    dvth_dibl   = -(ETA0_t + ETAB_i * vbgx) * Theta_DIBL * (vdsx + ETA1_i * sqrt(vdsx + 0.01)) + (DVTP0_i * Theta_DITS * pow((vdsx + 0.01), DVTP1_i));
    dvth_dsc    = -DSC0_i / (Leff + DSC1_i) * vdsx;
    T1          = csi * cox2 / (csi + cox2);
    T2          = (CDSCD_i + CBGCBGD * vbgxpos) * vdsx;
    T3          = CBGCBG0 * vbgx + CBGCBG0P * vbgx * vbgx + Theta_SCE * (CDSC_i + CBGCBG_i * vbgx + CBGCBGP * vbgx * vbgx + T2);
    nVtm        = Vtm * (cox1 + T1 + CIT_i + T3) / (cox1 + T1);


    // Threshold Voltage Shift Due to Body Doping, Ref: Noguchi et al. (EDL 2001)
    dvth_nbody = `q * NBODY_i * TSI / cox1 * (1.0 - 0.5 * TSI / (TSI + epsratio * EOT2));
    T0         = (KT2 + KT2L / Leff) * vbgx;
    dvth_temp  = dvth_temp0 + T0 * (TRatio - 1.0);
    dvth_all   = dvth_vtroll + dvth_dibl + dvth_rsce + dvth_dsc + dvth_nbody + dvth_temp + dvth_vbg + dvth_hci;

    // Threshold Voltage Operating Point
    A0         = (2.0 * `q * ni * TSI * TSI) / (epssi * Vtm);
    k1         = cox1 / csi;
    k2         = cox2 / csi;
    lnA0       = ln(A0);
    phi1_0     = ln(39.47841)-lnA0;
    k1_2       = k1*k1;
    keq_k2     = k1 / (k2*k1 + k2  + k1);
    qth        = 1.0;   // Assume Drift = Diffusion
    qsq1       = k1_2 * qth * qth - A0 * lexp(phib * 2.0);
    qsqrt1     = sqrt(qsq1);
    qcoth1     = (1.0 - qsqrt1 / 8.0) / (0.5 - qsqrt1 / 24.0);
    T1         = (1.0 + lln(k1 * k1 * qth * qth + k1 * qth * qcoth1) - lln(A0)) * Vtm;
    Vthop      = PHIG1_i - PhiRef + devsign * (T1 + dvth_all - DELVTRAND);
    T1         = cox1 + csi * cox2 / (csi + cox2);
    tmp        = 0.45 * Leff / scl + 1.0e-6;
    if (tmp < 40.0) begin
        T2 = 0.5 / (cosh(tmp) - 1.0);
    end else begin
        T2 = lexp(-tmp);
    end
    vgfb1eff   = vgfb1 + (nVtm / ((1 + 0.14 * T2 * (1 + vdsx) / T1) * Vtm) - 1) * keq_k2 - dvth_all + DELVTRAND;

    // ******************************************************************
    // **  Source Surface Potential and Charge Calculation (New Core)  **
    // ******************************************************************

    xg1 = vgfb1eff / nVtm;
    xg2 = (vgfb2 - dvth_all + DELVTRAND) / (nVtm);
    /////////////////////////////BEGIN CORE CALCULATION////////////////////////////////////////////
    /////////////////saturation potential at back gate
    PHISsatback = ln((k1_2*(xg1-phi1_0)*(xg1-phi1_0)+39.47841))-lnA0;//ln((k2*k2*(xg2-phi1_0)*(xg2-phi1_0)+39.47841))-lnA0;  //aproximation for saturation voltage in gate back
    PHISsat = ln((k1_2*(xg1-phi1_0)*(xg1-phi1_0)+39.47841))-lnA0;
    PHISsatback2 = (PHISsat + k2 * xg2) / (1.0 + k2);
    //phi2 guess using only PHISsatback and PHISsatback2
    phi2sub= xg2 + keq_k2* (xg1 - xg2);

    phi2 = min(phi2sub,PHISsatback);
    phi2 = min(phi2,phi1_0);

    phi1  = (phi2 + k1 * xg1) / (1.0 + k1);
    T0 = phi1 - phi2;
    T3 = lexp(phi2) * (lexp(T0)-1.0)/T0;
   /////////////////////begin sat potential calculation
    q2= xg2-PHISsatback2;
    qsqrt = k2*k2*q2*q2 -A0 * exp(PHISsatback2);
    if (qsqrt<0.0) begin //qsqrt for negative case
        q2= (xg2-phi2)*k2;
        q1= 40.0*k1;//assume a given q1 in strong inversion 1.0/nVtm
        qt = q1+q2;
        T3 = q1*q2;
        T4 = 0.06534*qt+1.0;//(1.0/6.0-1.0/pi_2)*qt+1.0;
        T5 = qt*8.57973+T3+39.47841;//qt*(2.0*(1.0+pi_2/3.0))+T3+T2;
        T6 = 78.95683*qt+39.47841*T3;
        qsqrt = (-T5 + sqrt(-4.0*T4*T6 + T5*T5))/(2.0*T4);

        T3 = (phi1_0*(1.0 + k1)-phi2)/k1;
        T0 = 40*(xg1-T3+2.0)/5.0;
        qsqrt = qsqrt*(1.0-exp(-(xg1-T3+2.0)/(2.0/0.69)));
        qsqrt = min(qsqrt,50.0);
    end

    /////////////////saturation potential at front gate
    xg1=max(xg1,phi1_0);
    PHISsat = ln((k1_2*(xg1-phi1_0)*(xg1-phi1_0)+39.47841))-lnA0;


    T3 = (phi1_0*(1.0 + k1)-phi2)/k1;
    T4 = ln((k1_2*(T3-phi1_0)*(T3-phi1_0)+39.47841))-lnA0;
    T5 = T4-phi1_0;
    PHISsat = PHISsat-T5;

    q1 = xg1-PHISsat;
    T0 = -A0*exp(PHISsat);
    T1 = k1_2*q1;
    delta = -(T1*q1+T0-qsqrt)/(-2.0*T1+T0);
    PHISsat = PHISsat +delta;

    q1 = xg1-PHISsat;
    T2 = k1_2 * q1;
    T0  = 1.0/(T2 * q1 -qsqrt);
    g= ln(abs((T2 * q1 -qsqrt)))-lnA0 - PHISsat;
    dg1  = 1.0/(-2.0 * T2 * T0 - 1.0);
    dg2  = -4.0 * T2 * T2 * T0 * T0 + 2.0 * k1_2 * T0;
    T1 = g * dg1;
    delta =  - T1 - 0.5*T1*T1*dg2*dg1;
    delta = max(delta,-10.0);
    delta = min(delta,10.0);
    PHISsat = PHISsat +delta;

    q1 = xg1-PHISsat;
    T2 = k1_2 * q1;
    T0  = 1.0/(T2 * q1 -qsqrt);
    g= ln(abs((T2 * q1 -qsqrt)))-lnA0 - PHISsat;
    dg1  = 1.0/(-2.0 * T2 * T0 - 1.0);
    dg2  = -4.0 * T2 * T2 * T0 * T0 + 2.0 * k1_2 * T0;
    T1 = g * dg1;
    delta =  - T1 - 0.5*T1*T1*dg2*dg1;
    delta = max(delta,-10.0);
    delta = min(delta,10.0);
    PHISsat = PHISsat +delta;

    PHISsat=max(PHISsat,phi1_0-4.0);

    xg1 = vgfb1eff / nVtm;
    phi1 =  phi1 -  1.0*ln(1.0 + exp((phi1-1.05*PHISsat)/1.0));
    phi1 = min(phi1,PHISsat);
    /////////////////////end sat potential calculation
    `include "bsimimg_sp_new.include"

    q1 = xg1-phi1;
    T0 = A0 *exp(phi1);
    qsqrt = k1_2 * q1 * q1 -  T0 ;
    if (qsqrt < 0.0) begin
        q  = sqrt(-qsqrt);
        T2 = 0.5 * q;
        qcoth  = q / tan(T2);
        T6 = sin(T2);
        T1 = -T6 * T6;
    end else begin
        q  = sqrt(qsqrt);
        T2 = 0.5 * q;
        T6 = sinh(T2);
        T1 = T6 * T6;
        qcoth  = q /tanh(T2);
    end
    qicores = (k1 * q1 - qcoth) / (1.0 - qsqrt /(T1*T0));

/////////////////////////////END CORE CALCULATION////////////////////////////////////////////

    qfronts = q1 * cox1 * nVtm;
    qtots   = qicores*csi * nVtm;
    qbacks  = qtots-qfronts;
    phi2 = xg2-qbacks/(cox2 * nVtm);
    phifs   = (phi1 + phi2) * nVtm / 2.0; // for Igc
    // Drain Saturation Voltage, Ref: BSIM4, PSP
    qis   = qtots / cox1;
    qbs   = `q * NBODY_i * TSI / cox1;
    T2    = eta_mu * qfronts / cox1 + qbs;
    T3    = 0.5 * (T2 + sqrt(T2 * T2 + 0.001));
    Eeffs = EeffFactor * T3;

    T2     = eta_mu2 * qbacks / cox2 + qbs;
    T3     = 0.5 * (T2 + sqrt(T2 * T2 + 0.001));
    Eeffs2 = EeffFactor2 * T3;

    begin: Calc_Source_Mobility
        real T2, T3;
        qb0   = 1.0e-2 / cox1;
        T2    = pow(0.5 * (1.0 + abs(qis / qb0)), UCS_t);
        T3    = (UA_t + vbgs * UC_t) * pow(abs(Eeffs), EU_i + EUB_i * vbgs) + UD_t / T2;
        Dmobs = 1.0 + T3;
        Dmobs = smoothminx(Dmobs, 1.0, DMOBCLAMP);
        Dmobs = Dmobs / U0MULT;
        ueff1 = U0_t / Dmobs;
    end

    begin: Calc_Source_Mobility_back
        real T2, T3;
        T2    = pow(0.5 * (1.0 + abs(qis / qb0)), UCS2_i);
        T3    = (UA2_i + vbgs * UC2_i) * pow(abs(Eeffs2), EU2_i + EUB2_i * vbgs) + UD2_i  / T2;
        Dmobs = 1.0 + T3;
        Dmobs = smoothminx(Dmobs, 1.0, DMOBCLAMP);
        Dmobs = Dmobs / U0MULT;
        ueff2 = U02_i / Dmobs;
    end

    T0     = vgfb1eff - qfronts / cox1;
    T1     = vgfb2 - dvth_all - qbacks / cox2;
    w1     = exp(T0 / nVtm) / (exp(T0 / nVtm) + exp(T1 / nVtm));
    w2     = exp(T1 / nVtm) / (exp(T0 / nVtm) + exp(T1 / nVtm));
    utotal = w1 * ueff1 + w2 * ueff2;

    if (RDSMOD == 1) begin
        Rdss = 0.0;
    end else if (RDSMOD == 0) begin
        T4   = 1.0 + PRWG_i * qis;
        T1   = 1.0 / T4;
        T0   = 0.5 * (T1 + sqrt(T1 * T1 + 0.01));
        Rdss = (RDSWMIN_i + RDSW_i * T0) * WeffWRFactor * NF * rdstemp;
    end else begin
        T4   = 1.0 + PRWG_i * qis;
        T1   = 1.0 / T4;
        T0   = 0.5 * (T1 + sqrt(T1 * T1 + 0.01));
        Rdss = (RSourceGeo + RDrainGeo + (RDSWMIN_i + RDSW_i * T0) * WeffWRFactor * NF) * rdstemp + RSC0_t + RDC0_t;
    end

    Esat  = 2.0 * VSAT_t / utotal;
    EsatL = Esat * Leff;
    T6    = KSATIV_i * (qis + KSATIVB_i * vbgxpos + 2.0 * Vtm * KSUBIV_i);

    if (Rdss > 0.0) begin
        WVCox = Weff * VSAT_t * cox1;
        T0    = WVCox * Rdss;
        Ta    = 2.0 * T0;
        Tb    = T6 + EsatL + 3.0 * T6 * T0;
        Tc    = T6 * (EsatL + 2.0 * T6 * T0);
        Vdsat = (Tb - sqrt(Tb * Tb - 2.0 * Ta * Tc)) / Ta;
    end else begin
        Vdsat = EsatL * T6 / (EsatL + T6);
    end

    Vdsat  = hypsmooth(Vdsat - 1.0e-3, 1.0e-5) + 1.0e-3;
    T7     = pow(vds / Vdsat, MEXP_t);
    T8     = pow(1.0 + T7, inv_MEXP);
    Vdseff = vds / T8;

    if (Vdseff > vds) begin
        Vdseff = vds;
    end

    // *****************************************************************
    // **  Drain Surface Potential and Charge Calculation (New Core)  **
    // *****************************************************************
    xg1 = (vgfb1eff-Vdseff) / nVtm;
    xg2 = (vgfb2 - dvth_all + DELVTRAND-Vdseff) / (nVtm);

    /////////////////////////////BEGIN CORE CALCULATION////////////////////////////////////////////
    /////////////////saturation potential at back gate
    PHISsatback = ln((k1_2*(xg1-phi1_0)*(xg1-phi1_0)+39.47841))-lnA0;//ln((k2*k2*(xg2-phi1_0)*(xg2-phi1_0)+39.47841))-lnA0;  //aproximation for saturation voltage in gate back
    PHISsat = ln((k1_2*(xg1-phi1_0)*(xg1-phi1_0)+39.47841))-lnA0;
    T3 = (phi1_0*(1.0 + k1)-phi2)/k1;
    T4 = ln((k1_2*(T3-phi1_0)*(T3-phi1_0)+39.47841))-lnA0;
    T5 = T4-phi1_0;
    PHISsat = PHISsat-T5;
    PHISsatback2 = (PHISsat + k2 * xg2) / (1.0 + k2);
    //phi2 guess using only PHISsatback and PHISsatback2
    phi2sub= xg2 + keq_k2* (xg1 - xg2);

    phi2 = min(phi2sub,PHISsatback);
    phi2 = min(phi2,phi1_0);

    phi1  = (phi2 + k1 * xg1) / (1.0 + k1);
    T0 = phi1 - phi2;

    T3 = lexp(phi2) * (lexp(T0)-1.0)/T0;
/////////////////////begin sat potential calculation

    q2= xg2-PHISsatback2;
    qsqrt = k2*k2*q2*q2 -A0 * exp(PHISsatback2);
    if (qsqrt<0.0) begin //qsqrt for negative case
        q2= (xg2-phi2)*k2;
        q1= 40.0*k1;//assume a given q1 in strong inversion 1.0/nVtm
        qt = q1+q2;
        T3 = q1*q2;
        T4 = 0.06534*qt+1.0;//(1.0/6.0-1.0/pi_2)*qt+1.0;
        T5 = qt*8.57973+T3+39.47841;//qt*(2.0*(1.0+pi_2/3.0))+T3+T2;
        T6 = 78.95683*qt+39.47841*T3;
        qsqrt = (-T5 + sqrt(-4.0*T4*T6 + T5*T5))/(2.0*T4);

        T3 = (phi1_0*(1.0 + k1)-phi2)/k1;
        T0 = 40*(xg1-T3+2.0)/5.0;
        qsqrt = qsqrt*(1.0-exp(-(xg1-T3+2.0)/(2.0/0.69)));
        qsqrt = min(qsqrt,50.0);
    end

    /////////////////saturation potential at front gate
    xg1=max(xg1,phi1_0);
    PHISsat = ln((k1_2*(xg1-phi1_0)*(xg1-phi1_0)+39.47841))-lnA0;
    T3 = (phi1_0*(1.0 + k1)-phi2)/k1;
    T4 = ln((k1_2*(T3-phi1_0)*(T3-phi1_0)+39.47841))-lnA0;
    T5 = T4-phi1_0;
    PHISsat = PHISsat-T5;

    q1 = xg1-PHISsat;
    T0 = -A0*exp(PHISsat);
    T1 = k1_2*q1;
    delta = -(T1*q1+T0-qsqrt)/(-2.0*T1+T0);
    PHISsat = PHISsat +delta;

    q1 = xg1-PHISsat;
    T2 = k1_2 * q1;
    T0  = 1.0/(T2 * q1 -qsqrt);
    g= ln(abs((T2 * q1 -qsqrt)))-lnA0 - PHISsat;
    dg1  = 1.0/(-2.0 * T2 * T0 - 1.0);
    dg2  = -4.0 * T2 * T2 * T0 * T0 + 2.0 * k1_2 * T0;
    T1 = g * dg1;
    delta =  - T1 - 0.5*T1*T1*dg2*dg1;
    delta = max(delta,-10.0);
    delta = min(delta,10.0);
    PHISsat = PHISsat +delta;

    q1 = xg1-PHISsat;
    T2 = k1_2 * q1;
    T0  = 1.0/(T2 * q1 -qsqrt);
    g= ln(abs((T2 * q1 -qsqrt)))-lnA0 - PHISsat;
    dg1  = 1.0/(-2.0 * T2 * T0 - 1.0);
    dg2  = -4.0 * T2 * T2 * T0 * T0 + 2.0 * k1_2 * T0;
    T1 = g * dg1;
    delta =  - T1 - 0.5*T1*T1*dg2*dg1;
    delta = max(delta,-10.0);
    delta = min(delta,10.0);
    PHISsat = PHISsat +delta;

    PHISsat = max(PHISsat,phi1_0-4.0);

    xg1 = (vgfb1eff-Vdseff) / nVtm;
    phi1 =  phi1 -  1.0*ln(1.0 + exp((phi1-1.05*PHISsat)/1.0));
    phi1 = min(phi1,PHISsat);

    /////////////////////end sat potential calculation
    `include "bsimimg_sp_new.include"

   // if (qtotaldfirst<20.0) begin
    q1 = xg1-phi1;
    T0 = A0 *exp(phi1);
    qsqrt = k1_2 * q1 * q1 -  T0 ;
    if (qsqrt < 0.0) begin
        q  = sqrt(-qsqrt);
        T2 = 0.5 * q;
        qcoth  = q / tan(T2);
        T6 = sin(T2);
        T1 = -T6 * T6;
    end else begin
        q  = sqrt(qsqrt);
        T2 = 0.5 * q;
        T6 = sinh(T2);
        T1 = T6 * T6;
        qcoth  = q /tanh(T2);
    end
    qicored = (k1 * q1 - qcoth) / (1.0 - qsqrt /(T1*T0));

    qfrontd = q1 * cox1 * nVtm;
    qtotd   = qicored*csi * nVtm;
    qbackd  = qtotd-qfrontd;
    phi2 = xg2-qbackd/(cox2 * nVtm);
/////////////////////////////END CORE CALCULATION////////////////////////////////////////////
    // Average Potential and Charge
    qid = qtotd / cox1;
    qia = 0.5 * (qis + qid);
    dqi = qis - qid;
    qba = `q * NBODY_i * TSI / cox1;

    T0 = pow(Vdseff, 2.0) / 6.25e-4;
    if (CHARGEWF != 0.0) begin
        qia2 = (qfronts + qfrontd) / (2.0 * cox1) + CHARGEWF * (1.0 - lexp(-T0)) * 0.5 * (qfronts - qfrontd) / cox1;
    end else begin
        qia2 = (qfronts + qfrontd) / (2.0 * cox1);
    end

    if (CHARGEWF2 != 0.0) begin
        qib2 = (qbacks + qbackd) / (2.0 * cox2) + CHARGEWF2 * (1.0 - lexp(-T0)) * 0.5 * (qbacks - qbackd) / cox2;
    end else begin
        qib2 = (qbacks + qbackd) / (2.0 * cox2);
    end

    // Mobility Degradation, Ref: BSIM4, PSP
    T2    = eta_mu * qia2 + qba;
    T3    = 0.5 * (T2 + sqrt(T2 * T2 + 0.001));
    Eeffm = EeffFactor * T3;

    T2    = eta_mu2 * qib2 + qba;
    T3    = 0.5 * (T2 + sqrt(T2 * T2 + 0.001));
    Eeffm2 = EeffFactor2 * T3;

    begin: Calc_Average_Mobility
        real T2, T3;
        T2   = pow(0.5 * (1.0 + abs(qia / qb0)), UCS_t);
        T3   = (UA_t + vbgx * UC_t) * pow(abs(Eeffm), EU_i + EUB_i * vbgx) + (UD_t + vbgx * UDB_i) / T2;
        Dmob = 1.0 + T3;
        Dmob = smoothminx(Dmob, 1.0, DMOBCLAMP);
        Dmob = Dmob / U0MULT;
        ueff1 = U0_t / Dmob;
    end

    begin: Calc_Average_Mobility_back
        real T2, T3;
        T2   = pow(0.5 * (1.0 + abs(qia / qb0)), UCS2_i);
        T3   = (UA2_i + vbgx * UC2_i) * pow(abs(Eeffm2), EU2_i + EUB2_i * vbgx) + (UD2_i + vbgx * UDB2_i) / T2;
        Dmob = 1.0 + T3;
        Dmob = smoothminx(Dmob, 1.0, DMOBCLAMP);
        Dmob = Dmob / U0MULT;
        ueff2 = U02_i / Dmob;
    end

    T0     = vgfb1eff - (qfronts + qfrontd) / (2.0 * cox1);
    T1     = vgfb2 - dvth_all - (qbacks + qbackd) / (2.0 * cox2);
    w1     = exp(T0 / nVtm) / (exp(T0 / nVtm) + exp(T1 / nVtm));
    w2     = exp(T1 / nVtm) / (exp(T0 / nVtm) + exp(T1 / nVtm));
    utotal = w1 * ueff1 + w2 * ueff2;

    // Multiplication factor for I-V
    beta = utotal * cox1 * Weff / Leff;

    // Mobility Degradation for C-V
    Eeffm_cv = EeffFactor * (qba + eta_mu_cv * qia);
    T3       = UA_t * pow(abs(Eeffm_cv), EU_i);
    Dmob_cv  = 1.0 + T3;
    Dmob_cv  = smoothminx(Dmob_cv, 1.0, DMOBCLAMP);
    Dmob_cv  = Dmob_cv / U0MULT;

    // Velocity Saturation
    Esat1  = 2.0 * VSAT1_t / utotal;
    Esat1L = Esat1 * Leff;

    T0     = 0.8 + VSATB_t * vbgx;
    Xsat   = 0.2 + 0.5 * (T0 + sqrt(T0 * T0 + 0.01));
    T0     = dqi / Esat1L * Xsat;
    Dvsat  = (1.0 + sqrt(DELTAVSAT + T0 * T0)) / (1.0 + sqrt(DELTAVSAT));
    Dvsat  = Dvsat + 0.5 * (PTWG_t - PTWGB_i * vbgxpos - PTWGB2_i * vbgx) * qia * dqi * dqi;
    Dvsat  = smoothminx(Dvsat, 1.0, DVSATCLAMP);

    EsatCV  = 2.0 * VSATCV_t * Dmob_cv / U0_t;
    EsatCVL = EsatCV * LeffCV;

    // Output Conductance
    if (PVAG_i > 0.0) begin
        PVAGfactor = 1.0 + PVAG_i * qia / EsatL;
    end else begin
        PVAGfactor = 1.0 / (1.0 - PVAG_i * qia / EsatL);
    end

    diffVds  = vds - Vdseff;
    Vgst2Vtm = qia + 2.0 * Vtm;

    if (DIBLfactor > 0.0) begin
        T1     = Vgst2Vtm;
        T3     = T1 / (Vdsat + T1);
        VaDIBL = T1 / DIBLfactor * T3 * PVAGfactor;
        Moc    = 1.0 + diffVds / VaDIBL;
    end else begin
        Moc = 1.0;
    end

    if (PCLM_i > 0.0) begin
        if (PCLMG < 0.0) begin
            T1 = 1.0 / (1.0 / PCLM_i - PCLMG * qia);
        end else begin
            T1 = PCLM_i * (1.0 + PCLMG * qia);
        end
        Mclm = 1.0 + T1 * lln(1.0 + diffVds / T1 / (Vdsat + EsatL));
    end else begin
        Mclm = 1.0;
    end
    Moc = Moc * Mclm;

    // Channel Length Modulation for C-V
    if (PCLMCV_i > 0.0) begin
        MclmCV = 1.0 + PCLMCV_i * lln(1.0 + (vds - Vdseff) / PCLMCV_i / (Vdsat + EsatCVL));
    end else begin
        MclmCV = 1.0;
    end

    T1   = K0_t / (max(0.0, K0SI_t + K0SISAT_t * dqi * dqi) * qia + 2.0 * nVtm);
    Mnud = lexp(-T1);

    // I-V Equation
    T0          = qicores - qicored;
    T1          = qicores * qicores - qicored * qicored;
    ids0        = csi * nVtm * 2.0 * Vtm * T0 + csi * nVtm * csi * nVtm * 0.5 * T1 / cox1;
    ids0_ov_dqi = 0.5 * (qis + qid) + Vtm;

    // Source/Drain Resistances
    begin: Rds_Block
        real T1, T4;
        real vgs_eff, vgd_eff, T2, T3;
        if (RDSMOD == 1) begin
            Rdsi    = 0.0;
            Dr      = 1.0;
            T2      = vgs_noswap - vfbsd;
            T3      = sqrt(T2 * T2 + 1.0e-4);
            vgs_eff = 0.5 * (T2 + T3);
            T4      = 1.0 + PRWG_i * vgs_eff;
            T1      = 1.0 / T4;
            T1      = T1 - 0.5 * vbgs_noswap * PRWB_i;
            T0      = 0.5 * (T1 + sqrt(T1 * T1 + 0.01));
            Rsource = rdstemp * (RSourceGeo + (RSWMIN_i + RSW_i * T0) * WeffWRFactor) + RSC0_t;
            T2      = vgd_noswap - vfbsd;
            T3      = sqrt(T2 * T2 + 1.0e-4);
            vgd_eff = 0.5 * (T2 + T3);
            T4      = 1.0 + PRWG_i * vgd_eff;
            T1      = 1.0 / T4;
            T1      = T1 - 0.5 * vbgd_noswap * PRWB_i;
            T0      = 0.5 * (T1 + sqrt(T1 * T1 + 0.01));
            Rdrain  = rdstemp * (RDrainGeo + (RDWMIN_i + RDW_i * T0) * WeffWRFactor) + RDC0_t;
        end else begin
            T4      = 1.0 + PRWG_i * qia;
            T1      = 1.0 / T4;
            T1      = T1 - 0.5 * (vbgd + vbgs) * PRWB_i;
            T0      = 0.5 * (T1 + sqrt(T1 * T1 + 0.01));
            if (RDSMOD == 2) begin
                Rdsi = rdstemp * ((RDSWMIN_i + RDSW_i * T0) * WeffWRFactor + RSourceGeo + RDrainGeo) + RDC0_t + RSC0_t;
                Dr      = 1.0 + NF * beta * ids0_ov_dqi / (Dvsat) * Rdsi;
                Rdrain  = 0.0;
                Rsource = 0.0;
            end else begin
                Rdsi    = rdstemp * ((RDSWMIN_i + RDSW_i * T0) * WeffWRFactor);
                Dr      = 1.0 + NF * beta * ids0_ov_dqi / (Dvsat) * Rdsi;
                Rdrain  = rdstemp * RDrainGeo + RDC0_t;
                Rsource = rdstemp * RSourceGeo + RSC0_t;
            end
        end
    end

    ids = (beta / cox1) * ids0 * Moc * Mnud / (Dvsat * Dr);
    ids = NF * ids;

    // C-V Equation
    qfg = (qfrontd + qfronts) / 2.0;
    qd  = (1.0 / 6.0) * (qtots + 2.0 * qtotd);
    qs  = (1.0 / 6.0) * (2.0 * qtots + qtotd);
    qbg = (qbackd + qbacks) / 2.0;

    // Quantum Mechanical Effects
    if (QMTCENCV_i > 0.0) begin
        T4     = (qia + ETAQM_i * qba) / QM0_i;
        T5     = 1.0 + pow(T4, PQM_i);
        Tcen0  = TSI;
        Tcen   = Tcen0 / T5;
        coxeff = 3.9 * `EPS0 / (IMGTOXP * 3.9 / EPSROX1 + Tcen * QMTCENCV_i / epsratio);
    end else begin
        coxeff = cox1P;
    end

    T0  = coxeff / cox1 * WeffCV * LeffCV / MclmCV;
    qfg = qfg * T0;
    qd  = -qd * T0;
    qbg = qbg * T0;
    qs  = -qs * T0;

    // Parasitic Capacitances
    // Note: the back gate capacitance is assumed to be negligible due to the thick oxide.
    qfgs_ov = WeffCV * LOVS_i * cox1 * V(ge, si);
    qfgd_ov = WeffCV * LOVD_i * cox1 * V(ge, di);

    // Bias-Dependent Overlap Capacitances
    vfbsd_bg = devsign * (PHIG2_i - PhiSD);

    T0      = vgs_ov_noswap - vfbsd + `DELTA_1 + (EOT1 / EOT2) * (vbgs_noswap - vfbsd_bg - PCOVBS0) * PCOVBS1;
    vfgs_ov = 0.5 * (T0 - sqrt(T0 * T0 + 4.0 * `DELTA_1));
    T1      = vgs_ov_noswap - vfbsd - vfgs_ov;
    qfgs_ov = qfgs_ov + devsign * WeffCV * CGSL * (T1 - 0.5 * CKAPPAS * (sqrt(1.0 - 4.0 * vfgs_ov / CKAPPAS)- 1.0));

    T0      = vgd_ov_noswap - vfbsd + `DELTA_1 + (EOT1 / EOT2) * (vbgd_noswap - vfbsd_bg - PCOVBD0) * PCOVBD1;
    vfgd_ov = 0.5 * (T0 - sqrt(T0 * T0 + 4.0 * `DELTA_1));
    T1      = vgd_ov_noswap - vfbsd - vfgd_ov;
    qfgd_ov = qfgd_ov + devsign * WeffCV * CGDL * (T1 - 0.5 * CKAPPAD * (sqrt(1.0 - 4.0 * vfgd_ov / CKAPPAD)- 1.0));

    // Outer Fringe Capacitances
    qfgs_of = WeffCV * CFS_i * V(ge, si);
    qfgd_of = WeffCV * CFD_i * V(ge, di);

    qfgs_parasitic = qfgs_ov + qfgs_of;
    qfgd_parasitic = qfgd_ov + qfgd_of;

    Qsbg = devsign * csbox * V(si, bg);
    Qdbg = devsign * cdbox * V(di, bg);

    // Impact Ionization Current
    T0 = (ALPHA0_i + ALPHA1_i * Leff) / Leff;

    if ((T0 <= 0.0) || (BETA0_t <= 0.0)) begin
        Iii = 0.0;
    end else if (diffVds > BETA0_t / `EXPL_THRESHOLD) begin
        T1  = - BETA0_t / diffVds;
        Iii = T0 * diffVds * ids * lexp(T1);
    end else begin
        Iii = T0 * diffVds * ids * `MIN_EXPL;
    end

    // Gate Current, Ref: BSIM4, BSIM-CMG
    igbinv = 0.0;
    igbacc = 0.0;
    igcs   = 0.0;
    igcd   = 0.0;
    igs    = 0.0;
    igd    = 0.0;

    // Igb
    if (IGBMOD != 0) begin
        // Igbinv
        T1          = (qia - EIGBINV_i) / NIGBINV_i / Vtm;
        Vaux_Igbinv = NIGBINV_i * Vtm * lln(1.0 + lexp(T1));

        T2     = AIGBINV_i - BIGBINV_i * qia;
        T3     = 1.0 + CIGBINV_i * qia;
        T4     = -9.82222e11 * TOXP * T2 * T3;
        T5     = lexp(T4);
        T6     = 3.75956e-7;
        igbinv = Weff * Leff * T6 * Toxratio * vgbg * Vaux_Igbinv * T5;
        igbinv = igbinv * igtemp;

        // Igbacc
        vfbzb = deltaphi1 - phib;
        T0    = vfbzb - vgbg;
        T1    = T0 / NIGBACC_i / Vtm;

        Vaux_Igbacc = NIGBACC_i * Vtm * lln(1.0 + lexp(T1));

        if (vfbzb <= 0.0) begin
            Voxacc = 0.5 * (T0 - 0.02 + sqrt((T0 - 0.02) * (T0 - 0.02) - 0.08 * vfbzb));
        end else begin
            Voxacc = 0.5 * (T0 - 0.02 + sqrt((T0 - 0.02) * (T0 - 0.02) + 0.08 * vfbzb));
        end

        T2 = AIGBACC_i - BIGBACC_i * Voxacc;
        T3 = 1.0 + CIGBACC_i * Voxacc;
        T4 = -7.45669e11 * TOXP * T2 * T3;
        T5 = lexp(T4);
        T6 = 4.97232e-7;
        igbacc = Weff * Leff * T6 * Toxratio * vgbg * Vaux_Igbacc * T5;
        igbacc = igbacc * igtemp;
    end

    // Gate to Body Tunneling Current Partition
    T0   = tanh(0.6 * vds_noswap / Vtm);
    wf   = 0.5 + 0.5 * T0;
    wr   = 1.0 - wf;
    igbs = wf * (igbinv + igbacc);
    igbd = wr * (igbinv + igbacc);


    if (IGCMOD != 0) begin
        // Igcinv
        T1       = AIGC_i - BIGC_i * (vgfb1 - DIGC_i * phifs);
        T2       = 1.0 + CIGC_i * (vgfb1 - DIGC_i * phifs);
        T3       = -Bechvb * TOXP * T1 * T2;
        T4       = qia * lexp(T3);
        T5       = vgbg + 0.5 * vdsx + 0.5 * (vbgs_noswap + vbgd_noswap);
        igc0     = Weff * Leff * Aechvb * Toxratio * T4 * T5 * igtemp;

        // Gate-Current Partition
        Vdseffx  = sqrt(Vdseff * Vdseff + 0.01) - 0.1;
        T1       = PIGCD_i * Vdseffx;
        T1_exp   = lexp(-T1);
        T3       = T1 + T1_exp - 1.0 + 1.0e-4;
        T4       = 1.0 - (T1 + 1.0) * T1_exp + 1.0e-4;
        T5       = T1 * T1 + 2.0e-4;
        igcd     = igc0 * T4 / T5;
        igcs     = igc0 * T3 / T5;

        // Igs
        T0       = vgs_noswap - vfbsd + DIGS_i * gamma0 * (vbgs - vfbsd_bg);
        vfgs_eff = sqrt(T0 * T0 + 1.0e-4);
        T1       = AIGS_i - BIGS_i * vfgs_eff;
        T2       = 1.0 + CIGS_i * vfgs_eff;
        T3       = -Bechvb * TOXP * POXEDGE_i * T1 * T2;
        T4       = lexp(T3);

        if (sigvds > 0.0) begin
            igs = igsd_mult * DLCIGS * vgs_noswap * vfgs_eff * T4;
        end else begin
            igd = igsd_mult * DLCIGS * vgs_noswap * vfgs_eff * T4;
        end

        // Igd
        T0       = vgd_noswap - vfbsd + DIGD_i * gamma0 * (vbgs - vfbsd_bg);
        vfgd_eff = sqrt(T0 * T0 + 1.0e-4);
        T1       = AIGD_i - BIGD_i * vfgd_eff;
        T2       = 1.0 + CIGD_i * vfgd_eff;
        T3       = -Bechvb * TOXP * POXEDGE_i * T1 * T2;
        T4       = lexp(T3);

        if (sigvds > 0.0) begin
            igd = igsd_mult * DLCIGD * vgd_noswap * vfgd_eff * T4;
        end else begin
            igs = igsd_mult * DLCIGD * vgd_noswap * vfgd_eff * T4;
        end
    end


    // GIDL and GISL Currents
    igisl = 0.0;
    igidl = 0.0;

    if (GIDLMOD != 0) begin
        T0 = epsratio * EOT1;

        // GIDL
        if ((AGIDL_i <= 0.0) || (BGIDL_t <= 0.0)) begin
            T6 = 0.0;
        end else begin
            T1 = (-vgd_noswap - EGIDL_i + vfbsd  + VBGIDL_i * gamma0 * (vbgs - vfbsd_bg - VBEGIDL_i)) / T0;
            T1 = hypsmooth(T1, 1.0e-2);
            T2 = BGIDL_t / (T1 + 1.0e-3);
            T3 = lexp(PGIDL_i * lln(T1));
            T6 = AGIDL_i * Weff * T3 * lexp(-T2) * vds_noswap;
        end

        if (sigvds > 0.0) begin
            igidl = T6;
        end else begin
            igisl = T6;
        end

        // GISL
        if ((AGISL_i <= 0.0) || (BGISL_t <= 0.0)) begin
            T6 = 0.0;
        end else begin
            T1 = (-vgs_noswap - EGISL_i + vfbsd + VBGISL_i * gamma0 * (vbgs - vfbsd_bg - VBEGISL_i)) / T0;
            T1 = hypsmooth(T1, 1.0e-2);
            T2 = BGISL_t / (T1 + 1.0e-3);
            T3 = lexp(PGISL_i * lln(T1));
            T6 = -vds_noswap * AGISL_i * Weff * T3 * lexp(-T2);
        end
        if (sigvds > 0.0) begin
            igisl = T6;
        end else begin
            igidl = T6;
        end
    end

    // ********************
    // **  Noise Models  **
    // ********************

    Esatnoi = 2.0 * VSAT_t / utotal;

    // Flicker Noise, Ref: BSIM4, K. K. Hung et al., TED 1990 and P. Kushwaha et. al. EDL 2019
    if (NOIA > 0.0 || NOIB > 0.0 || NOIC > 0.0) begin
        Leffnoi   = Leff - 2.0 * LINTNOI_i;
        Leffnoisq = Leffnoi * Leffnoi;

        if (EM <= 0.0) begin
            DelClm = 0.0;
        end else begin
            T0     = (diffVds / litl + EM) / Esatnoi;
            DelClm = litl * lln(T0);
            if (DelClm < 0.0) begin
                DelClm = 0.0;
            end
        end

        if (FNMOD == 1 && NOIA > 0.0) begin
            T1 = qia2/QSREF_i;
            T2 = 1 + pow(T1, MPOWER_i);
            T3 = NOIA2_i/T2;
            T4 = T3 / NOIA;
            T5 = 0.5 * (T4 + 1 + sqrt((T4 - 1) * (T4 - 1) + 0.25 * SMOOTH * SMOOTH));
            NOIAeff = NOIA * T5;
        end else begin
            NOIAeff = NOIA;
        end

        T1  = `q * `q * `q * Vtm * abs(ids) * utotal;
        T2  = 1.0e10 * coxeff * Leffnoisq;
        N0  = coxeff * qis / `q;
        Nl  = coxeff * qid / `q;

        Nstar = Vtm / `q * (coxeff + CIT_i);
        T3    = NOIAeff * lln((N0 + Nstar) / (Nl + Nstar));
        T4    = NOIB * (N0 - Nl);
        T5    = 0.5 * NOIC * (N0 * N0 - Nl * Nl);

        T6    = `q * Vtm * ids * ids;

        T7  = 1.0e10 * Leffnoisq * Weff * NF;
        T8  = NOIAeff + NOIB * Nl + NOIC * Nl * Nl;
        T9  = (Nl + Nstar) * (Nl + Nstar);
        Ssi = T1 / T2 * (T3 + T4 + T5) + T6 / T7 * DelClm * T8 / T9;

        T10 = NOIAeff * `q * Vtm;
        T11 = Weff * NF * Leffnoi * 1.0e10 * Nstar * Nstar;

        Swi = T10 / T11 * ids * ids;

        T1  = Swi + Ssi;

        if (T1 > 0.0) begin
            FNPowerAt1Hz = (Ssi * Swi) / T1;
        end else begin
            FNPowerAt1Hz = 0.0;
        end

    end else begin
        FNPowerAt1Hz = 0.0;
    end

    // Intrinsic Charges
    qfgi = devsign * NF * qfg;
    qbgi = NF * qbg;

    if (sigvds > 0.0) begin
        qsi = NF * qs;
        qdi = NF * qd;
        qs  = NF * (qs - qfgs_parasitic) + Qsbg;
        qd  = NF * (qd - qfgd_parasitic) + Qdbg;
    end else begin
        qsi = NF * qd;
        qdi = NF * qs;
        T0  = NF * (qd - qfgs_parasitic) + Qsbg;
        qd  = NF * (qs - qfgd_parasitic) + Qdbg;
        qs  = T0;
    end

    qfg = qfgi + NF * (qfgs_parasitic + qfgd_parasitic);
    qbg = NF * qbg - Qsbg - Qdbg;

    qfgs_parasitic = NF * qfgs_parasitic;
    qfgd_parasitic = NF * qfgd_parasitic;


    rc = 2.0 * cox1 / csi;
    q0 = 10.0 * nVtm / rc + 2.0 * qbs;

    ctnoi = 1;
    sid = 1;
    sigrat = 1;
    Nt = 4.0 * Vtm * `q;
    case (TNOIMOD)
        // Charge-based thermal noise model, Ref: BSIM4
        0: begin
            qinv  = -(qsi + qdi);
            T0    = utotal * qinv;
            T1    = T0 * Rdsi + Leff * Leff;
            Gtnoi = (T0 / T1) * NTNOI;
            Nt    = 4.0 * Vtm * `q;
            sid   = Nt * Gtnoi;
        end
        // Correlated thermal noise model, Ref: Chap. 6 of Darsen Lu's Ph.D. thesis
        1: begin
            T0 = qia / EsatL;
            T0 = T0 * T0;
            // Empirical parameters for short-channel excess noise
            noiBeta  = RNOIA * (1.0 + T0 * TNOIA * Leff);
            noiTheta = RNOIB * (1.0 + T0 * TNOIB * Leff);
            noiCorr  = RNOIC * (1.0 + T0 * TNOIC * Leff);
            noiLowId = RNOIK * (1.0 + T0 * TNOIK * Leff);
            // T1, T2, T3 are all 1.0 by default
            T1 = 3.0 * noiBeta * noiBeta;
            T2 = 7.5 * noiTheta * noiTheta;
            T3 = 2.5298 * noiCorr;
            // Theoretical equations
            noiEta = (qid / qis) * (1.0 - Vdseff / Vdsat);
            Dvsat3 = Dvsat * Dvsat * Dvsat;
            noiWI  = q0 / (q0 + qia);
            // Mnud at Vds = 0

            T4    = K0_t / (max(0.0, K0SI_t) * qis + 2.0 * nVtm);
            Mnud0 = lexp(-T4);
            Mob0  = 1.0;
            // Dmob at Vds = 0
            Eeffm0 = EeffFactor * (qba + eta_mu * qis);
            T4     = pow(0.5 * (1.0 + abs(qis / qb0)), UCS_t);
            T5     = UA_t * pow(abs(Eeffm0), EU_i) + UD_t / T4;
            Dmob0  = 1.0 + T5;
            Dmob0  = smoothminx(Dmob0, 1.0, DMOBCLAMP);
            Dmob0  = Dmob0 / U0MULT;
            // Dvsat at Vds = 0
            Dvsat0 = 1.0 + 0.25 * DVSATCLAMP;
            // ids0_ov_dqi at Vds = 0
            etaiv0       = q0 / (q0 + qis);
            T4           = (2.0 - etaiv0) * nVtm;
            ids0_ov_dqi0 = qis + T4;
            // Dr at Vds = 0
            case (RDSMOD)
                0: begin
                    T4    = 1.0 + PRWG_i * qis;
                    T5    = 1.0 / T4;
                    T6    = 0.5 * (T5 + sqrt(T5 * T5 + 0.01));
                    Rdsi0 = rdstemp * (RDSWMIN_i + RDSW_i * T6) * WeffWRFactor;
                    Dr0   = 1.0 + NF * beta * ids0_ov_dqi0 / (Dmob0 * Dvsat0) * Rdsi0;
                end
                1: begin
                    Dr0 = 1.0;
                end
                2: begin
                    T4    = 1.0 + PRWG_i * qis;
                    T5    = 1.0 / T4;
                    T6    = 0.5 * (T5 + sqrt(T5 * T5 + 0.01));
                    Rdsi0 = (RDSWMIN_i + RDSW_i * T6) * WeffWRFactor;
                    Rdsi0 = rdstemp * (RSourceGeo + RDrainGeo +  Rdsi0) + RDC0_t + RSC0_t;
                    Dr0   = 1.0 + NF * beta * ids0_ov_dqi0 / (Dmob0 * Dvsat0) * Rdsi0;
                end
            endcase
            // Gds at Vds = 0, Moc will always be 1.0 at Vds = 0
            noiGd0 = NF * beta * qis * Mnud0 * Mob0 / (Dmob0 * Dvsat0 * Dr0);
            T4     = 1.0 + noiEta;
            T5     = 1.0 - noiEta;
            T6     = (2.0 * noiWI) / qis * nVtm;
            T7     = T4 + T6;
            T5_2   = T5 * T5;
            T5_3   = T5_2 * T5;
            T5_4   = T5_3 * T5;
            T7_2   = T7 * T7;
            T7_3   = T7_2 * T7;
            T7_4   = T7_3 * T7;
            T7_5   = T7_4 * T7;
            // Theoretical Sid for long-channel devices
            gamma1 = 0.5 * T4;
            gamma2 = T5_2 / (6.0 * T7);
            gamma  = (Moc / Dvsat) * (gamma1 + gamma2);
            // Theoretical Sig for long-channel devices
            delta1      = T4 / T7_2;
            delta2      = (6.0 * T4 + T6) * T5_2 / (15.0 * T7_4);
            delta3      = T5_4 / (9.0 * T7_5);
            delta_therm = (Moc / 6.0) * Dvsat3 * (delta1 - delta2 + delta3);
            // Theoretical correlated noise between Sid and Sig for long-channel devices
            epsilon1 = T5 / T7;
            epsilon2 = T5_3 / (3.0 * T7_3);
            epsilon  = (Moc / 6.0) * Dvsat * (epsilon1 - epsilon2);
            // Empirical tuning of correlation coefficient between Sid and Sig by T3
            // ctnoi = 1: fully correlated; ctnoi = 0: uncorrelated
            ctnoi = T3 * epsilon / sqrt(gamma * delta_therm);
            if (ctnoi > 1.0) begin
                ctnoi = 1.0;
            end else if (ctnoi < 0.0) begin
                ctnoi = 0.0;
            end
            // Empirical tuning of Sid, T1: saturation region, T8: subthreshold and linear region
            T8    = 1.0 + noiLowId * noiLowId / (TNOIK2 + qia) * (Vdseff / Vdsat);
            gamma = (Moc / Dvsat) * (T8 * gamma1 + T1 * gamma2);
            // Sid level
            sid = Nt * gamma * noiGd0;
            // Empirical tuning of Sig by T2, RNOIB = 0 turns Sig off
            delta_therm = (Moc / 6.0) * Dvsat3 * T2 * (delta1 - delta2 + delta3);
            // Sig ratio to Sid
            sigrat = sqrt(delta_therm / gamma) * NF * coxeff * WeffCV * LeffCV / noiGd0;
        end
    endcase

    // NQS gate resistance Ref: BSIM4
    if (NQSMOD == 1 && XRCRG1_i != 0.0) begin
        T0       = utotal * cox1 * Weff / Leff;
        IdsovVds = T0 * qia;
        gcrg     = NF * XRCRG1_i * (IdsovVds + XRCRG2_i * Vtm * T0);
    end else begin
        gcrg     = 0.0;
    end

    // Loading Variables
    igidl = NF * igidl;
    igisl = NF * igisl;
    igcd  = NF * igcd;
    igcs  = NF * igcs;
    igs   = NF * igs;
    igd   = NF * igd;

    if (sigvds > 0.0) begin
        I(di, si) <+ MULT_I * (devsign * ids + ($simparam("gmin",0) * V(di, si)));
        I(di, si) <+ devsign * MULT_I * (igidl + Iii);
        I(si, di) <+ devsign * MULT_I * igisl;
        I(gi, si) <+ devsign * MULT_I * (igcs + igs);
        I(gi, di) <+ devsign * MULT_I * (igcd + igd);
    end else begin
        I(si, di) <+ MULT_I * (devsign * ids + ($simparam("gmin",0) * V(si, di)));
        I(si, di) <+ devsign * MULT_I * (igidl + Iii);
        I(di, si) <+ devsign * MULT_I * igisl;
        I(gi, di) <+ devsign * MULT_I * (igcs + igs);
        I(gi, si) <+ devsign * MULT_I * (igcd + igd);
    end


    I(gi, si)  <+ devsign * MULT_I * igbs;
    I(gi, di)  <+ devsign * MULT_I * igbd;

    I(di, si)  <+ devsign * ddt(MULT_Q * qdi);
    I(gi, si)  <+ ddt(MULT_Q * qfgi);
    I(bg, si)  <+ devsign * ddt(MULT_Q * qbgi);
    I(ge, si)  <+ ddt(MULT_Q * qfgs_parasitic);
    I(ge, di)  <+ ddt(MULT_Q * qfgd_parasitic);

    I(si, bg)  <+ devsign * ddt(MULT_Q * Qsbg);
    I(di, bg)  <+ devsign * ddt(MULT_Q * Qdbg);


    if (RDSMOD != 2 && (RDrainGeo > 0 || RDC0 > 0 || (RDSMOD == 1 && (RDW_i > 0 || RDWMIN_i > 0)))) begin
        gdpr = 1 / Rdrain;
        I(d, di) <+ MULT_I * V(d, di) * gdpr;
        I(d, di) <+ white_noise(MULT_I * Nt * gdpr, "Rd");
    end else begin
        V(d, di) <+ 0.0;
    end

    if (RDSMOD != 2 && (RSourceGeo > 0 || RSC0 > 0 || (RDSMOD == 1 && (RSW_i > 0 || RSWMIN_i > 0)))) begin
        gspr = 1 / Rsource;
        I(s, si) <+ MULT_I * V(s, si) * gspr;
        I(s, si) <+ white_noise(MULT_I * Nt * gspr, "Rs");
    end else begin
        V(s, si) <+ 0.0;
    end

    // NQSMOD1 Gate Resistance Model
    if (NQSMOD == 1 && XRCRG1_i != 0.0)
        I(ge, gi) <+ MULT_I * V(ge, gi) * gcrg;
    else
        V(ge, gi) <+ 0.0;


    if (RGATEMOD == 0) begin
        V(fg, ge) <+ 0.0;
    end else begin: Rgate
        real Ggate, Gnoise;
        Ggate  = Grgeltd;
        Gnoise = Grgeltd;
        I(fg, ge) <+ MULT_I * V(fg, ge) * Ggate;
        I(fg, ge) <+ white_noise(MULT_I * Nt * Gnoise, "Rg");
    end

    // Flicker Noise
    I(di,si) <+ flicker_noise(sigvds * MULT_FN * FNPowerAt1Hz, EF, "1overf");

    // Channel thermal noise and induced gate noise stamping (TNOIMOD from BSIM-CMG)
    if (TNOIMOD == 0) begin
        I(di, si) <+ white_noise(MULT_I * sid, "Id");
        V(n) <+ 0.0;
    end else begin
        // Additional node for correlated noise
        I(n) <+ V(n);
        I(n) <+ white_noise(sid, "corl");
        I(di, si) <+ white_noise(MULT_I * sid * (1.0 - ctnoi * ctnoi), "id");
        I(di, si) <+ ctnoi * MULT_I * V(n);
        // Correlated Sig noise to S/D through capacitive coupling
        I(gi, si) <+ ddt(0.7071 * MULT_Q * sigrat * V(n));
        I(gi, di) <+ ddt(0.7071 * MULT_Q * sigrat * V(n));
    end

    // Gate Current Shot Noise
    if (IGCMOD != 0) begin
        if (sigvds > 0.0) begin
            I(gi, si) <+ white_noise(2.0 * `q * MULT_I * abs(igcs + igs), "Igs");
            I(gi, di) <+ white_noise(2.0 * `q * MULT_I * abs(igcd + igd), "Igd");
        end else begin
            I(gi, di) <+ white_noise(2.0 * `q * MULT_I * abs(igcs + igs), "Igd");
            I(gi, si) <+ white_noise(2.0 * `q * MULT_I * abs(igcd + igd), "Igs");
        end
    end

    if (IGBMOD != 0) begin
        I(gi, si) <+ white_noise(2.0 * `q * MULT_I * abs(igbs), "Igb");
        I(gi, di) <+ white_noise(2.0 * `q * MULT_I * abs(igbd), "Igb");
    end

    // Self-heating
    if (SHMOD != 0 && RTH0 > 0.0) begin
        Pwr(ith_branch) <+ -(devsign * sigvds * V(di, si) * (ids + Iii) + V(d, di) * V(d, di) * gdpr + V(s, si) * V(s, si) * gspr);
        Pwr(rth_branch) <+ Temp(rth_branch) * gth;
        Pwr(rth_branch) <+ ddt(Temp(rth_branch) * cth);
    end else begin
        Temp(t) <+ 0.0;
    end

    // Operation Point Info
    Lterm0 = 0.15 * (Lnew - 10e-9) / 10e-9 + 1.12;
    Lterm  = Lterm0 / pow(1 + pow(Lterm0 / 1.45, 3), 0.33);

    VDSSAT = devsign * Vdsat * Lterm / pow(1 + pow(Vdsat / 0.5, 1.8), 1 / 1.8);

    VTH    = Vthop + devsign * (minx(-0.958 * vgfb2 * EOT1 / EOT2 + (TSI - 12e-9) * 2.78e15 * EOT1 * vgfb2 - 3.71e9 * EOT1 * lexp(-Leff / 8.4e-9), -(EOT1 + 0.37e-8) / EOT2 * vgfb2 - (TSI - 12e-9) * 2.68e7 * vgfb2 - 7.42e9 * EOT1 * lexp(-Leff / 9e-9), 0.1));

    // Conductances
    IDS  = devsign * sigvds * MULT_I * ids;
    GM   = ddx(IDS, V(gi));
    GMBS = ddx(IDS, V(bg));

    if (sigvds > 0.0) begin
        VFGS = V(fg, s);
        VFGD = V(fg, d);
        VDS  = V(d, s);
        VSBG = V(s, bg);
        VDBG = V(d, bg);
        GDS  = ddx(IDS, V(di));
        if (abs(GDS) > 1.0e-16) begin
            ROUT = 1/GDS;
        end else if (GDS >= 0.0) begin
            ROUT = 1.0e16;
        end else begin
            ROUT = -1.0e16;
        end
    end else begin
        VFGS = V(fg, d);
        VFGD = V(fg, s);
        VDS  = V(s, d);
        VSBG = V(d, bg);
        VDBG = V(s, bg);
        GDS  = ddx(-IDS, V(si));
        if (abs(GDS) > 1.0e-16) begin
            ROUT = 1/GDS;
        end else if (GDS >= 0.0) begin
            ROUT = 1.0e16;
        end else begin
            ROUT = -1.0e16;
        end
    end

    // Total Source/Drain Currents
    if (sigvds > 0.0) begin
        ID = IDS - devsign * MULT_I * (igd + igcd + igbd) + devsign * MULT_I * (Iii + igidl - igisl);
        IS = -IDS - devsign * MULT_I * (igs + igcs + igbs) + devsign * MULT_I * (igisl - igidl);
    end else begin
        ID = IDS - devsign * MULT_I * (igs + igcs + igbd) + devsign * MULT_I * (igisl - igidl);
        IS = -IDS - devsign * MULT_I * (igd + igcd + igbs) + devsign * MULT_I *  (Iii + igidl - igisl);
    end

    // Total Gate Current
    IFG = devsign * MULT_I * (igs + igd + igcs + igcd + igbs + igbd);

    // Impact Ionization Current
    III = devsign * MULT_I * Iii;

    // GIDL and GISL Currents
    if (sigvds > 0.0) begin
        IGIDL = devsign * MULT_I * igidl;
        IGISL = devsign * MULT_I * igisl;
    end else begin
        IGIDL = devsign * MULT_I * igisl;
        IGISL = devsign * MULT_I * igidl;
    end

    // Intrinsic Charges
    QFGI = MULT_Q * qfgi;
    QBGI = devsign * MULT_Q * qbgi;
    QDI  = devsign * MULT_Q * qdi;
    QSI  = devsign * MULT_Q * qsi;

    // Total Charges
    QFG  = MULT_Q * qfg;
    QBG  = devsign * MULT_Q * qbg;
    QD   = devsign * MULT_Q * qd;
    QS   = devsign * MULT_Q * qs;

    // Intrinsic Capacitances
    CFGDI  = -ddx(QFGI, V(di));
    CFGFGI = ddx(QFGI, V(gi));
    CFGSI  = -ddx(QFGI, V(si));
    CSFGI  = -ddx(QSI, V(gi));
    CFGBGI = -ddx(QFGI, V(bg));
    CBGDI  = -ddx(QBGI, V(di));
    CBGFGI = -ddx(QBGI, V(gi));
    CBGSI  = -ddx(QBGI, V(si));
    CSBGI  = -ddx(QSI,V(bg));
    CBGBGI = ddx(QBGI, V(bg));
    CDDI   = ddx(QDI, V(di));
    CDFGI  = -ddx(QDI, V(gi));
    CDSI   = -ddx(QDI, V(si));
    CDBGI  = -ddx(QDI, V(bg));

    // Total Capacitances
    CFGD   = -ddx(QFG, V(di));
    CFGFG  = CFGFGI + ddx(devsign * MULT_Q * (qfgs_parasitic + qfgd_parasitic), V(ge));
    CFGS   = -ddx(QFG, V(si));
    CSFG   = CSFGI + ddx(devsign * MULT_Q * qfgs_parasitic, V(ge));
    CFGBG  = -ddx(QFG, V(bg));
    CBGD   = -ddx(QBG, V(di));
    CBGFG  = -ddx(QBG, V(gi));
    CBGS   = -ddx(QBG, V(si));
    CSBG   = -ddx(QS,V(bg));
    CBGBG  = ddx(QBG, V(bg));
    CDD    = ddx(QD, V(di));
    CDFG   = CDFGI + ddx(devsign * MULT_Q * qfgd_parasitic, V(ge));
    CDS    = -ddx(QD, V(si));
    CDBG   = -ddx(QD, V(bg));

    // Output for self-heating temperature
    T_TOTAL_K  = DevTemp;
    T_TOTAL_C  = DevTemp - `P_CELSIUS0;
    T_DELTA_SH = Temp(t);

    //Power dissipation
    PDISS = devsign * sigvds * V(di, si) * MULT_I * (ids + Iii) + V(d, di) * V(d, di) * MULT_I * gdpr + V(s, si) * V(s, si) * MULT_I * gspr;
    V(qin) <+ qinv;
end
